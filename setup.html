<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firebase Bingo Platform - Setup</title>
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <style>
        :root { --accent-color: #00aaff; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #1a1a1a;
            color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .navbar {
            width: 100%;
            max-width: 1200px; /* Match controls width */
            background-color: #2d2d2d; /* Match controls bg */
            border-radius: 8px;
            padding: 0.5rem 1rem;
            margin-bottom: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
        }
        .nav-links a {
            color: #f0f0f0;
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            transition: background-color 0.2s;
        }
        .nav-links a:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .nav-links a.active {
            background-color: var(--accent-color);
            color: #111;
            font-weight: bold;
        }
        /* Modal Styles (adapted from admin.html) */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7); backdrop-filter: blur(4px); justify-content: center; align-items: center; }
        .modal-content { background-color: #2d2d2d; padding: 2rem; border-radius: 12px; width: 90%; max-width: 500px; position: relative; text-align: center; }
        .modal-content .close-button { color: #aaa; position: absolute; top: 1rem; right: 1.5rem; font-size: 28px; font-weight: bold; cursor: pointer; }
        .modal-content h3 { margin-top: 0; color: #e57373; }
        .modal-content p { text-align: center; }
        .modal-content input { width: 100%; padding: 10px; margin: 1rem 0; box-sizing: border-box; background-color: #1a1a1a; color: #f0f0f0; border: 1px solid #444; border-radius: 4px; }
        .modal-content button { background-color: #dc3545; width: 100%; }
        .modal-content button:disabled { background-color: #555; cursor: not-allowed; }
        .button-like-link {
            background-color: #17a2b8; /* A different color */
            color: white;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            text-decoration: none;
            transition: background-color 0.3s;
            display: inline-block;
            text-align: center;
        }
        .button-like-link:hover { background-color: #138496; }
        /* --- NEW: Global Loader & Message Box --- */
        .global-loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 3px;
            background: linear-gradient(to right, var(--accent-color) 20%, #00d9f5 50%, var(--accent-color) 80%);
            background-size: 200% auto;
            animation: loading-animation 1.5s linear infinite;
            z-index: 9999; display: none;
        }
        @keyframes loading-animation { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
        #message-box {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background-color: #333; color: white; padding: 1rem 2rem; border-radius: 8px;
            z-index: 2000; opacity: 0; transition: opacity 0.5s; pointer-events: none;
        }
        #message-box.show { opacity: 1; }
        h1, h2 {
            color: var(--accent-color);
            text-align: center;
        }
        p {
            text-align: center;
            max-width: 800px;
        }
        .container {
            display: flex;
            flex-direction: column; /* Always stack vertically */
            gap: 20px;
            width: 100%;
            max-width: 1200px; /* Match the controls width */
        }
        .outputs-container {
            display: flex;
            gap: 20px;
            width: 100%;
            align-items: flex-start;
        }
        .editor-panel {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .output-panel {
            width: 100%;
            display: flex;
            flex: 1; /* Allow panels to grow */
            flex-direction: column;
        }
        /* This is now the viewport for panning and zooming */
        #board-container {
            position: relative;
            width: 100%;
            /* REVISED: Removed max-width to fill the new container */
            margin: auto;
            border-radius: 8px;
            overflow: hidden; /* Crucial for panning effect */
            border: 2px solid #444;
            cursor: grab;
        }
        #board-container:active {
            cursor: grabbing;
        }
        /* This new element will be scaled and moved */
        #board-content {
            position: relative;
            width: 100%;
            transform-origin: top left;
            transition: transform 0.1s ease-out;
            background-repeat: no-repeat;
            background-position: top left;
            background-size: 100% 100%;
        }
        #board-image {
            display: block;
            width: 100%;
            height: auto;
        }
        .draggable-tile {
            position: absolute;
            border: 2px solid rgba(255, 255, 255, 0.7);
            background-color: rgba(0, 170, 255, 0.3);
            color: white;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-sizing: border-box;
            cursor: move;
            touch-action: none;
            user-select: none;
            z-index: 1; /* To be under the prerequisite lines */
            padding: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: pointer; /* Change cursor to indicate it's clickable */
        }
        #csv-output {
            width: 100%;
            height: 400px; /* Adjusted height slightly */
            font-family: 'Courier New', Courier, monospace;
            background-color: #2d2d2d;
            color: #f0f0f0;
            border: 1px solid #444;
            border-radius: 4px;
            resize: vertical;
            box-sizing: border-box; /* Ensure padding/border is included in width */
        }
        .output-buttons {
            display: flex;
            gap: 10px;
        }
        button {
            background-color: #00aaff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #0088cc;
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.7;
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            justify-content: center;
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            width: 100%;
            max-width: 1200px;
        }
        .main-actions {
            display: flex;
            gap: 15px;
        }
        .file-inputs {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        .file-inputs > div {
            display: flex;
            flex-direction: column;
        }
        .file-inputs label {
            margin-bottom: 5px;
            font-size: 14px;
        }
        .file-inputs input {
            font-size: 14px;
        }
        .zoom-control, .lock-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .prereq-vis-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .prereq-vis-control select {
            background-color: #1a1a1a;
            color: #f0f0f0;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 5px;
        }
        #prereq-lines-svg {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none; z-index: 5;
            overflow: visible;
        }
        /* Details Panel Styles */
        .details-panel {
            width: 100%;
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            box-sizing: border-box;
        }
        .details-header {
            display: flex;
            justify-content: flex-start;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 15px;
            gap: 15px;
        }
        .details-header h2 {
            margin: 0;
            flex-shrink: 0;
        }
        #add-new-tile-btn {
            margin-top: 0;
            background-color: #28a745;
        }
        #tile-selector-dropdown {
            flex-grow: 1;
            background-color: #1a1a1a;
            color: #f0f0f0;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 8px;
            max-width: 400px;
        }
        #delete-tile-btn {
            margin-top: 0;
            background-color: #dc3545;
        }
        #delete-all-tiles-btn {
            margin-top: 0;
            background-color: #c82333; /* A darker red */
        }
        #toggle-global-styles-btn {
            margin-top: 0;
            padding: 5px 10px;
            font-size: 18px;
        }
        #details-form {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
        }
        .form-field {
            display: flex;
            flex-direction: column;
        }
        .form-field label {
            margin-bottom: 5px;
            font-size: 14px;
            color: #aaa;
        }
        .form-field input, .form-field textarea, .form-field select {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            background-color: #1a1a1a;
            color: #f0f0f0;
            border: 1px solid #444;
            border-radius: 4px;
        }
        .form-field textarea {
            resize: vertical;
            min-height: 80px;
            font-family: 'Courier New', Courier, monospace;
        }
        .form-field input:disabled, .form-field textarea:disabled, .form-field select:disabled {
            background-color: #2a2a2a;
            cursor: not-allowed;
            color: #666;
        }
        .overrides-fieldset {
            grid-column: 1 / -1; /* Span all columns */
            border: 1px solid #444;
            border-radius: 4px;
            padding: 10px 15px;
        }
        .overrides-fieldset.minimized .fieldset-content {
            display: none;
        }
        .overrides-fieldset .fieldset-content {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            padding-top: 10px;
        }
        .legend-toggle {
            margin-right: 8px;
            font-weight: bold;
            display: inline-block;
            width: 1em;
        }
        .overrides-fieldset legend {
            color: var(--accent-color);
        }
        #overrides-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .override-item {
            display: grid;
            grid-template-columns: 150px 1fr 1fr 40px;
            gap: 10px;
            align-items: center;
        }
        #overrides-json-textarea {
            width: 100%;
            min-height: 100px;
            font-family: 'Courier New', Courier, monospace;
            background-color: #1a1a1a;
            color: #f0f0f0;
            border: 1px solid #444;
            border-radius: 4px;
            resize: vertical;
            box-sizing: border-box;
            margin-bottom: 10px;
        }
        #add-override-btn {
            background-color: #007bff;
            width: fit-content;
        }
        #add-override-btn:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        #style-preview-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
        }
        .remove-override-btn {
            background-color: #c0392b;
            padding: 8px;
        }
        .override-item input,
        .override-item select {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            background-color: #1a1a1a;
            color: #f0f0f0;
            border: 1px solid #444;
            border-radius: 4px;
        }
        .form-field-compound {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .form-field-compound input[type="color"] {
            padding: 0;
            height: 38px;
            width: 38px;
            flex-shrink: 0;
            border: none; /* Looks better without a border next to the text input */
        }
        .form-field-compound input[type="range"] {
            flex-grow: 1;
        }
        .color-text-input {
            font-family: 'Courier New', Courier, monospace;
            flex-grow: 1;
        }
        .form-field-compound input[type="text"] {
            /* Give text inputs in compound fields a fixed width */
            width: 80px;
        }
        .button-like-label {
            background-color: var(--accent-color);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            text-align: center;
            white-space: nowrap;
            transition: background-color 0.2s;
        }
        .button-like-label:hover {
            background-color: #0088cc; /* A darker shade of the accent */
        }
        #teams-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding-top: 10px;
        }
        .team-item {
            display: grid;
            grid-template-columns: 1fr 80px;
            gap: 10px;
            align-items: center;
        }
        .team-item input {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            background-color: #1a1a1a;
            color: #f0f0f0;
            border: 1px solid #444;
            border-radius: 4px;
        }
        #add-team-btn {
            margin-top: 10px;
            width: fit-content;
        }
        .remove-team-btn {
            background-color: #c0392b;
        }
        .team-item-header {
            display: grid;
            grid-template-columns: 100px 1fr 1fr 80px;
            gap: 10px;
            padding-bottom: 8px;
            font-weight: bold;
            color: #aaa;
            border-bottom: 1px solid #444;
        }
        /* New layout for the tile details form */
        #details-form {
            display: grid;
            grid-template-columns: repeat(10, 1fr); /* 10 columns for flexible layout */
            gap: 15px;
        }
        /* Assign fields to grid columns/rows */
        .form-field[data-key="docId"]        { grid-column: span 2; }
        .form-field[data-key="id"]           { grid-column: span 2; }
        .form-field[data-key="Name"]         { grid-column: span 3; }
        .form-field[data-key="Points"]       { grid-column: span 3; }

        .form-field[data-key="Description"]  { grid-column: 1 / -1; } /* Full width */

        /* 5 position fields on one row */
        .form-field[data-key="Left (%)"]     { grid-column: span 2; }
        .form-field[data-key="Top (%)"]      { grid-column: span 2; }
        .form-field[data-key="Width (%)"]    { grid-column: span 2; }
        .form-field[data-key="Height (%)"]   { grid-column: span 2; }
        .form-field[data-key="Rotation"]     { grid-column: span 2; }

        .form-field[data-key="Prerequisites"] { grid-column: 1 / -1; } /* Full width */
        

        .team-item {
            display: grid;
            grid-template-columns: 100px 1fr 1fr 80px;
            gap: 10px;
            align-items: center;
        }
        .team-id-display {
            background-color: #1a1a1a;
            padding: 8px;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
            color: #aaa;
            text-align: center;
        }
        .prereq-or-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            border: 1px solid #444;
            padding: 10px;
            border-radius: 4px;
            background-color: #1a1a1a;
        }
        #prereq-ui-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #prereq-editor-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .prereq-and-input {
            flex-grow: 1;
        }
        .config-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem; }
        .image-upload-preview {
            max-width: 100px; max-height: 50px; object-fit: contain; margin-top: 5px;
            border: 1px solid #444; background-color: #111; border-radius: 4px;
        }
        .prereq-or-label {
            font-weight: bold;
            color: var(--accent-color);
        }
        .error-message {
            padding: 2rem; background-color: #4d2a2a; border: 2px dashed #c0392b;
            border-radius: 8px; text-align: center; width: 80%; word-wrap: break-word;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 10;
        }
        .tooltip-icon {
            margin-left: 8px; color: #888; cursor: help; font-size: 0.8em;
            font-weight: normal; border-bottom: 1px dotted #888; display: inline-block;
        }
        .stamp-fieldset legend label {
            margin-bottom: 0; /* Override default form-field margin */
        }
        .prereq-validation-msg, .validation-msg {
            font-size: 0.8em; color: #e57373; margin-top: 4px;
            display: block; min-height: 1.2em;
        }

    </style>
</head>
<body>
<div id="global-loader" class="global-loader"></div>
<div id="message-box"></div>

<div id="main-content" style="display: block; width: 100%; display: flex; flex-direction: column; align-items: center;">
    <div id="access-denied" style="display: block;">
        <h1>Access Denied</h1>
        <p>You must be an Admin to view this page. Please log in with an authorized account.</p>
    </div>
    <div id="setup-view" style="display: none; width: 100%; display: flex; flex-direction: column; align-items: center;">
    <div class="navbar">
        <div class="nav-links">
            <a href="./index.html" target="_top">Player View</a>
            <a href="./overview.html" target="_top">Overview</a>
            <a href="./admin.html" target="_top">Admin View</a>
            <a href="./setup.html" target="_top" class="active">Board Setup</a>
        </div>
    </div>
    <h1>Bingo Board Live Editor</h1>
    <p>This is a live editor for the bingo board configuration. All changes to tiles, styles, and settings are saved to Firebase automatically.</p>

    <div class="controls">
        <div class="zoom-control">
            <label for="zoom-slider">Zoom:</label>
            <input type="range" id="zoom-slider" min="1" max="5" value="1" step="0.1">
            <span id="zoom-value">100%</span>
            <button id="reset-zoom">Reset</button>
        </div>
        <div class="prereq-vis-control">
            <label for="prereq-vis-mode">Prerequisite Lines:</label>
            <select id="prereq-vis-mode">
                <option value="hide" selected>Hidden</option>
                <option value="selected">Show for Selected</option>
            </select>
        </div>
        <div class="lock-control">
            <label for="lock-tiles-btn">Tile Editing:</label>
            <button id="lock-tiles-btn">Unlock Tiles</button>
        </div>
    </div>

    <div class="container">
        <div class="editor-panel">
            <div id="style-preview-controls"></div>
            <div id="board-container">
                <div id="board-content">
                    <img id="board-image" src="" alt="Bingo board background" style="visibility: hidden;" />
                    <svg id="prereq-lines-svg"></svg>
                    <!-- Tiles will be injected here -->
                </div>
            </div>
        </div>
        <div id="teams-editor-box" class="details-panel">
            <div class="details-header">
                <h2>Event Teams</h2>
                <button id="toggle-teams-btn" title="Toggle Visibility">-</button>
            </div>
            <form id="teams-form">
                <div class="team-item-header">
                    <span>Team ID</span>
                    <span>Team Name</span>
                    <span>Captain</span>
                    <span>Action</span>
                </div>
                <div id="teams-container"></div><button type="button" id="add-team-btn">+ Add New Team</button>
            </form>
        </div>
        <div id="global-style-editor-box" class="details-panel">
            <div class="details-header">
                <h2>Global Config &amp; Styles</h2>
                <button id="toggle-global-styles-btn" title="Toggle Visibility">-</button>
            </div>
            <div id="global-style-form">
                <p>Edit the global configuration below. Image fields support direct uploads. Changes will be reflected on the board live.</p>
                <!-- Fieldsets will be generated here by renderGlobalConfig -->
            </div>
        </div>
        <div id="tile-editor-box" class="details-panel">
            <div class="details-header">
                <h2>Edit Tile Details</h2>
                <select id="tile-selector-dropdown"></select>
                <button id="delete-tile-btn" disabled>Delete Selected Tile</button>
                <button id="add-new-tile-btn">Add New Tile</button>
                <a href="./import.html" class="button-like-link" target="_blank" rel="noopener noreferrer">Mass Import / Export</a>
                <button id="delete-all-tiles-btn">Delete All Tiles</button>
            </div>
            <form id="details-form"></form>
        </div>
    </div>
    </div>
</div>

<!-- NEW: Mass Delete Confirmation Modal -->
<div id="delete-all-modal" class="modal" style="display: none;">
    <div class="modal-content">
        <span class="close-button">&times;</span>
        <h3>Confirm Mass Deletion</h3>
        <p>This is an irreversible action. You are about to delete <strong>ALL</strong> tiles from the board. This cannot be undone.</p>
        <p>To confirm, please type <code style="background: #111; padding: 2px 5px; border-radius: 3px;">DELETE ALL</code> in the box below.</p>
        <input type="text" id="delete-confirm-input" autocomplete="off">
        <button id="delete-confirm-btn" disabled>Confirm Deletion</button>
    </div>
</div>

    <script type="module">
        import { db, storage, fb } from './firebase-config.js';
        import { initAuth } from './auth.js';

        let tilesData = [], allUsers = [], allTeams = {};
        let config = {}; // NEW: Central object for global config/styles
        let allStyles = {}; // NEW: Central object for status-specific styles
        let newTileCounter = 1;
        let lastSelectedTileIndex = null;
        let currentPreviewStatus = null;
        const STATUSES = ['Locked', 'Unlocked', 'Partially Complete', 'Submitted', 'Verified', 'Requires Action'];
        let prereqVisMode = 'hide';
        let isTilesLocked = true; // NEW: Lock state for tiles

        // NEW: Real-time listener unsubscribe functions
        let unsubscribeConfig = null;
        let unsubscribeTiles = null;
        let unsubscribeUsers = null;
        let unsubscribeTeams = null, unsubscribeStyles = null; // NEW

        // NEW: Schema-driven configuration
        const TILE_FIELDS = ['docId', 'id', 'Name', 'Points', 'Description', 'Left (%)', 'Top (%)', 'Width (%)', 'Height (%)', 'Rotation', 'Prerequisites'];
        const TILE_FIELD_DESCRIPTIONS = {
            'docId': 'The internal, unique, non-editable Firestore document ID.',
            'id': 'The user-facing "Tile ID" used for display and prerequisites (e.g., "B1"). Must be unique across all tiles.',
            'Name': 'The display name of the tile, shown on the board and in modals.',
            'Description': 'A longer description of the tile task, shown in the submission modal.',
            'Prerequisites': 'The requirements to unlock this tile. Use the UI below to define AND/OR logic. Raw format: a comma-separated list for a single AND group (e.g., "A1,A2"), or a JSON array for complex OR groups (e.g., [["A1","A2"],["B1"]]).',
            'Points': 'The number of points this tile is worth when completed.',
            'Rotation': 'The rotation of the tile on the board (e.g., "15deg").',
            'Top (%)': 'The position of the tile\'s top edge as a percentage of the board\'s height.',
            'Left (%)': 'The position of the tile\'s left edge as a percentage of the board\'s width.',
            'Width (%)': 'The width of the tile as a percentage of the board\'s width.',
            'Height (%)': 'The height of the tile as a percentage of the board\'s height.'
        };
        const configSchema = {
            // General
            pageTitle: { label: 'Page Title', type: 'text', description: 'The title displayed at the top of the bingo page and in the browser tab.' },
            boardImageUrl: { label: 'Board Background Image', type: 'image', path: 'config/board_background', description: 'A direct web URL to the bingo board background image. You can also upload a file here.' },
            maxPageWidth: { label: 'Max Page Width', type: 'text', description: 'The maximum width for the page content. Use px or % (e.g., 1400px or 90%).' },
            showTileNames: { label: 'Show Tile Names', type: 'boolean', description: 'Set to TRUE to display tile names on the board by default, especially if no background image is used.' },
            // Gameplay Rules
            unlockOnVerifiedOnly: { label: 'Unlock on Verified Only', type: 'boolean', description: 'Set to TRUE to require a tile to be "Verified" by an admin before its prerequisites are met for other tiles.' },
            scoreOnVerifiedOnly: { label: 'Score on Verified Only', type: 'boolean', description: 'Set to TRUE to only count points for "Verified" tiles on the scoreboard and overview.' },
            showScoreboard: { label: 'Show Scoreboard (Player Page)', type: 'boolean', description: 'Set to TRUE to display the team scoreboard at the bottom of the player page.' },
            enableOverviewPage: { label: 'Enable Public Overview Page', type: 'boolean', description: 'Set to TRUE to show the "Overview" link in the navbar for everyone. Admins can always see it.' },
            boardVisibility: { label: 'Board Visibility', type: 'select', options: ['public', 'private'], description: 'If "private", players can only see their own team\'s board state unless they are an admin.' },
            censorTilesBeforeEvent: { label: 'Censor Tiles Pre-Event', type: 'boolean', description: 'Set to TRUE to hide tile names and descriptions from all non-admins. Requires syncing the public layout below.' },
            evidenceFieldLabel: { label: 'Evidence Field Label', type: 'text', description: 'The text label displayed above the evidence submission inputs in the modal.' },
            loadFirstTeamByDefault: { label: 'Load First Team by Default', type: 'boolean', description: 'Set to TRUE to automatically load the first team in the list on the player page, instead of showing "Select a Team...".' },
            promptForDisplayNameOnLogin: { label: 'Prompt for Display Name', type: 'boolean', description: 'Set to TRUE to show a welcome modal on first login, prompting users to set a custom display name.' },
            welcomeMessage: { label: 'Welcome Message', type: 'textarea', description: 'The message shown in the welcome modal. Use {displayName} as a placeholder for the user\'s current name.' },
        };

        // NEW: Schema for properties within each style document
        const styleSchema = {
            // Appearance
            shape: { label: 'Tile Shape', type: 'select', options: ['Square', 'Ellipse', 'Circle', 'Diamond', 'Triangle', 'Hexagon'], description: 'The overall shape of the tiles.' },
            fill: { label: 'Tile Fill', type: 'colorAndOpacity', description: 'The background color and opacity for the tile.' },
            // Border
            border: { label: 'Border', type: 'widthAndColor', keys: { width: 'borderWidth', color: 'borderColor' }, unit: 'px', description: 'The tile\'s border width and color.' },
            // Hover Border
            hoverBorder: { label: 'Hover Border', type: 'widthAndColor', keys: { width: 'hoverBorderWidth', color: 'hoverBorderColor' }, unit: 'px', description: 'The border width and color on hover.' },
            // Stamp
            useStampByDefault: { label: 'Use Stamp', type: 'boolean', description: 'Toggles the use of a stamp image for this status. When enabled, the settings below will apply.' },
            stampImageUrl: { label: 'Stamp Image', type: 'image', path: 'styles/stamps/', description: 'URL for the stamp image to display on tiles. You can also upload a file.' },
            stampScale: { label: `Stamp Scale`, type: 'range', min: 0, max: 3, step: 0.05, description: `Size multiplier for the stamp (e.g., 1 is 100%, 0.5 is 50%).` },
            stampRotation: { label: `Stamp Rotation`, type: 'text', description: 'Rotation of the stamp (e.g., "45deg").' },
            stampPosition: { label: `Stamp Position`, type: 'text', description: 'CSS background-position value for the stamp (e.g., "center", "top left", "50% 50%").' }
        };

        const configGroups = {
            'Board Configuration': ['pageTitle', 'boardImageUrl', 'maxPageWidth', 'showTileNames', 'evidenceFieldLabel', 'loadFirstTeamByDefault'],
            'User Experience': ['promptForDisplayNameOnLogin', 'welcomeMessage'],
            'Rules & Visibility': ['unlockOnVerifiedOnly', 'scoreOnVerifiedOnly', 'showScoreboard', 'enableOverviewPage', 'boardVisibility', 'censorTilesBeforeEvent'],
        };

        // END NEW: Schema-driven configuration

        // Generate valid override properties from the schema, excluding general page config
        const VALID_OVERRIDE_PROPERTIES = [
            'shape', 'color', 'opacity',
            'borderWidth', 'borderColor',
            'hoverBorderWidth', 'hoverBorderColor',
            'useStampByDefault', 'stampImageUrl', 'stampScale', 'stampRotation', 'stampPosition'
        ].sort();


        let currentScale = 1;
        // Store pan coordinates
        let pan = { x: 0, y: 0 };

        const boardContainer = document.getElementById('board-container');
        const boardContent = document.getElementById('board-content'); // The new pannable/zoomable element
        const boardImage = document.getElementById('board-image');
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomValue = document.getElementById('zoom-value');
        const resetZoomBtn = document.getElementById('reset-zoom');
        const detailsPanel = document.getElementById('tile-editor-box');
        const detailsForm = document.getElementById('details-form');
        const addNewTileBtn = document.getElementById('add-new-tile-btn');
        const deleteTileBtn = document.getElementById('delete-tile-btn');
        const toggleGlobalStylesBtn = document.getElementById('toggle-global-styles-btn');
        const toggleTeamsBtn = document.getElementById('toggle-teams-btn');
        const prereqVisModeSelect = document.getElementById('prereq-vis-mode');
        const prereqLinesSvg = document.getElementById('prereq-lines-svg');

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('delete-all-tiles-btn').addEventListener('click', openDeleteAllModal);
            document.querySelector('#delete-all-modal .close-button').addEventListener('click', closeDeleteAllModal);
            document.getElementById('delete-confirm-input').addEventListener('input', validateDeleteAll);
            document.getElementById('delete-confirm-btn').addEventListener('click', executeDeleteAll);
            document.getElementById('lock-tiles-btn').addEventListener('click', toggleTileLock);
            createStylePreviewButtons();
            toggleTeams(); // Start with the teams panel minimized
            toggleGlobalStyles(); // Start with the panel minimized

            document.getElementById('tile-selector-dropdown').addEventListener('change', (event) => {
                const selectedIndex = event.target.value;
                const newIndex = selectedIndex !== '' ? parseInt(selectedIndex, 10) : null;
                
                // Only update if the selection actually changed
                if (newIndex !== lastSelectedTileIndex) {
                    updateEditorPanel(newIndex);
                    renderTiles(); // To highlight the new selection on the board
                }
            });

            applyTileLockState(); // Apply initial lock state on load

            // Initialize data fetching first, then authentication
            initializeApp();
            initAuth(onAuthStateChanged);
        });

        function onAuthStateChanged(authState) {
            if (authState.isAdmin) {
                document.getElementById('setup-view').style.display = 'flex';
                document.getElementById('access-denied').style.display = 'none';
                initializeApp();
            } else {
                document.getElementById('setup-view').style.display = 'none';
                document.getElementById('access-denied').style.display = 'block';
                // Provide a more specific message if the user is logged in but not an admin
                document.querySelector('#access-denied p').textContent = authState.isLoggedIn ? 'You must be an Admin to view this page.' : 'You must be logged in as an Admin to view this page.';
            }
        }

        function renderTiles() {
            boardContent.querySelectorAll('.draggable-tile').forEach(el => el.remove());
            if (!tilesData) return;
            const duplicateIds = getDuplicateIds(tilesData);
            tilesData.forEach((tile, index) => {
                const tileEl = document.createElement('div');
                tileEl.classList.add('draggable-tile');
                if (lastSelectedTileIndex === index) {
                    tileEl.style.borderColor = '#00d9f5'; // Highlight selected tile
                    tileEl.style.zIndex = 2; // Bring selected tile forward
                } else {
                    tileEl.style.zIndex = 1;
                }
                tileEl.dataset.index = index;

                // NEW: Add conflict styling
                if (duplicateIds.has(tile.id)) {
                    tileEl.style.outline = '3px solid #e57373';
                    tileEl.style.outlineOffset = '2px';
                } else {
                    tileEl.style.outline = '';
                }

                tileEl.textContent = tile.id;

                // --- NEW: Dynamic Styling ---
                const status = currentPreviewStatus || 'Unlocked';
                const getProp = (propName, status) => {
                    // 1. Check tile-specific overrides for the given status
                    if (tile['Overrides (JSON)']) {
                        try {
                            const overrides = JSON.parse(tile['Overrides (JSON)']);
                            if (overrides[status] && overrides[status][propName] !== undefined) {
                                return overrides[status][propName];
                            }
                        } catch (e) {}
                    }
                    // 2. Check status-specific styles
                    const statusStyle = allStyles[status];
                    if (statusStyle && statusStyle[propName] !== undefined) {
                        return statusStyle[propName];
                    }
                    // 3. Fallback to global config defaults
                    return config[propName];
                };

                tileEl.style.left = `${tile['Left (%)'] || 10}%`;
                tileEl.style.top = `${tile['Top (%)'] || 10}%`;
                tileEl.style.width = `${tile['Width (%)'] || 10}%`;
                tileEl.style.height = `${tile['Height (%)'] || 10}%`;
                tileEl.style.transform = `rotate(${tile['Rotation'] || '0deg'})`;
                
                const color = getProp('color', status) || '#888888';
                const opacity = getProp('opacity', status) || 0.5;
                tileEl.style.backgroundColor = hexToRgba(color, opacity);

                const borderWidth = getProp('borderWidth', status) || '2px';
                const borderColor = getProp('borderColor', status) || 'transparent';
                tileEl.style.border = `${borderWidth} solid ${borderColor}`;

                const shape = (getProp('shape', status) || 'Square').toLowerCase();
                const clipPaths = { 'ellipse': 'ellipse(50% 50% at 50% 50%)', 'circle': 'ellipse(50% 50% at 50% 50%)', 'diamond': 'polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)', 'triangle': 'polygon(50% 0%, 0% 100%, 100% 100%)', 'hexagon': 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)' };
                if (clipPaths[shape]) tileEl.style.clipPath = clipPaths[shape];

                // --- Stamp Logic ---
                const useStamp = getProp('useStampByDefault', status) === true;
                const stampUrl = getProp('stampImageUrl', status);

                if (useStamp && stampUrl) {
                    const scale = getProp('stampScale', status) || '1';
                    const rotation = getProp('stampRotation', status) || '0deg';
                    const position = getProp('stampPosition', status) || 'center';

                    tileEl.textContent = ''; // Clear ID/Name text when stamp is shown
                    const stampEl = document.createElement('div'); // Use a DIV for more reliable background positioning
                    stampEl.style.position = 'absolute';
                    stampEl.style.width = '100%';
                    stampEl.style.height = '100%';
                    stampEl.style.left = '0';
                    stampEl.style.top = '0';
                    stampEl.style.pointerEvents = 'none';
                    stampEl.style.zIndex = '1';

                    stampEl.style.backgroundImage = `url('${stampUrl}')`;
                    stampEl.style.backgroundRepeat = 'no-repeat';
                    stampEl.style.backgroundSize = 'contain';
                    stampEl.style.backgroundPosition = position;
                    stampEl.style.transformOrigin = position;
                    stampEl.style.transform = `scale(${scale}) rotate(${rotation})`;
                    tileEl.appendChild(stampEl);
                }

                tileEl.addEventListener('mouseover', () => {
                    const hoverWidth = getProp('hoverBorderWidth', status) || '3px';
                    const hoverColor = getProp('hoverBorderColor', status) || '#00d9f5';
                    tileEl.style.border = `${hoverWidth} solid ${hoverColor}`; // Use shorthand for robustness
                });
                tileEl.addEventListener('mouseout', () => {
                    tileEl.style.border = `${borderWidth} solid ${borderColor}`; // Revert to non-hover state
                });

                boardContent.appendChild(tileEl); // Append to the content div
            });
            renderPrereqLines(); // Re-render lines whenever tiles are re-rendered
        }


        // NEW: Function to apply the zoom and pan transform
        function applyTransform() {
            boardContent.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${currentScale})`;
        }

        function updateZoom() {
            currentScale = parseFloat(zoomSlider.value);
            zoomValue.textContent = `${Math.round(currentScale * 100)}%`;
            // When zooming, we might need to adjust the pan to keep the image centered
            // For simplicity now, we just apply the transform. A more advanced version could zoom towards the mouse pointer.
            applyTransform();
        }

        zoomSlider.addEventListener('input', updateZoom);

        resetZoomBtn.addEventListener('click', () => {
            zoomSlider.value = 1;
            pan = { x: 0, y: 0 }; // Reset pan on zoom reset
            updateZoom();
        });

        // NEW: Panning logic for the board container
        interact(boardContainer)
            .draggable({
                listeners: {
                    move(event) {
                        pan.x += event.dx;
                        pan.y += event.dy;
                        applyTransform();
                    }
                },
                // Only allow panning when the target is the container or image, not a tile
                allowFrom: '#board-content'
            });

        // REVISED: Tile interaction logic to correctly handle zoom
        interact('.draggable-tile')
            .draggable({
                listeners: {
                    move(event) {
                        const target = event.target;
                        const index = target.dataset.index;
                        if (!tilesData[index]) return;

                        const containerWidth = boardContainer.clientWidth;
                        const containerHeight = boardContainer.clientHeight;

                        // Correctly scale the mouse movement by the current zoom level
                        const dx_scaled = event.dx / currentScale;
                        const dy_scaled = event.dy / currentScale;

                        const x_pct = (parseFloat(target.style.left) || 0) + (dx_scaled / containerWidth * 100);
                        const y_pct = (parseFloat(target.style.top) || 0) + (dy_scaled / containerHeight * 100);

                        target.style.left = `${x_pct}%`;
                        target.style.top = `${y_pct}%`;

                        const x_pct_val = parseFloat(x_pct.toFixed(2));
                        const y_pct_val = parseFloat(y_pct.toFixed(2));
                        const dataToSave = {
                            'Left (%)': x_pct_val.toFixed(2),
                            'Top (%)': y_pct_val.toFixed(2)
                        };
                        tilesData[index]['Left (%)'] = dataToSave['Left (%)'];
                        tilesData[index]['Top (%)'] = dataToSave['Top (%)'];
                        debouncedSaveTile(tilesData[index].docId, dataToSave, null, null);
                        updateEditorPanel(index);
                        
                        renderPrereqLines();
                    }
                }
            })
            .resizable({
                edges: { left: true, right: true, bottom: true, top: true },
                listeners: {
                    move(event) {
                        const target = event.target;
                        const index = target.dataset.index;
                        if (!tilesData[index]) return;

                        const containerWidth = boardContainer.clientWidth;
                        const containerHeight = boardContainer.clientHeight;

                        let x_pct = parseFloat(target.style.left) || 0;
                        let y_pct = parseFloat(target.style.top) || 0;
                        
                        // event.rect contains the new width/height, which needs to be scaled
                        const width_pct = (event.rect.width / currentScale) / containerWidth * 100;
                        const height_pct = (event.rect.height / currentScale) / containerHeight * 100;

                        // event.deltaRect contains the change in position, also needs scaling
                        x_pct += (event.deltaRect.left / currentScale) / containerWidth * 100;
                        y_pct += (event.deltaRect.top / currentScale) / containerHeight * 100;

                        target.style.width = `${width_pct}%`;
                        target.style.height = `${height_pct}%`;
                        target.style.left = `${x_pct}%`;
                        target.style.top = `${y_pct}%`;
                        
                        const x_pct_val = parseFloat(x_pct.toFixed(2));
                        const y_pct_val = parseFloat(y_pct.toFixed(2));
                        const width_pct_val = parseFloat(width_pct.toFixed(2));
                        const height_pct_val = parseFloat(height_pct.toFixed(2));
                        const dataToSave = {
                            'Left (%)': x_pct_val.toFixed(2),
                            'Top (%)': y_pct_val.toFixed(2),
                            'Width (%)': width_pct_val.toFixed(2),
                            'Height (%)': height_pct_val.toFixed(2)
                        };
                        tilesData[index]['Left (%)'] = dataToSave['Left (%)'];
                        tilesData[index]['Top (%)'] = dataToSave['Top (%)'];
                        tilesData[index]['Width (%)'] = dataToSave['Width (%)'];
                        tilesData[index]['Height (%)'] = dataToSave['Height (%)'];
                        debouncedSaveTile(tilesData[index].docId, dataToSave, null, null);
                        updateEditorPanel(index);
                        
                        renderPrereqLines();
                    }
                }
            });

        // NEW: Tile Lock functions
        function applyTileLockState() {
            const lockBtn = document.getElementById('lock-tiles-btn');
            if (isTilesLocked) {
                interact('.draggable-tile').draggable(false).resizable(false);
                lockBtn.textContent = 'Unlock Tiles';
            } else {
                interact('.draggable-tile').draggable(true).resizable(true);
                lockBtn.textContent = 'Lock Tiles';
            }
        }

        function toggleTileLock() {
            isTilesLocked = !isTilesLocked;
            applyTileLockState();
        }

        function hexToRgba(colorStr, alpha) {
            if (!colorStr || typeof colorStr !== 'string') return `rgba(255, 255, 255, ${alpha})`;
            const sColor = colorStr.trim();
            if (sColor === 'transparent') return 'transparent';
            if (!sColor.startsWith('#')) return sColor;
            const hex = sColor.slice(1);
            let r = 0, g = 0, b = 0;
            if (hex.length === 3) { r = parseInt(hex[0] + hex[0], 16); g = parseInt(hex[1] + hex[1], 16); b = parseInt(hex[2] + hex[2], 16); }
            else if (hex.length === 6) { r = parseInt(hex.substring(0, 2), 16); g = parseInt(hex.substring(2, 4), 16); b = parseInt(hex.substring(4, 6), 16); }
            else { return `rgba(255, 255, 255, ${alpha})`; }
            if (isNaN(r) || isNaN(g) || isNaN(b)) return `rgba(255, 255, 255, ${alpha})`;
            return `rgba(${r},${g},${b},${alpha})`;
        }


        // --- Tile Selection & Editor Panel Logic ---

        
        function createEditorForm() {
            detailsForm.innerHTML = ''; // Clear previous form
            TILE_FIELDS.forEach(key => {
                const fieldContainer = document.createElement('div');
                fieldContainer.className = 'form-field';
                fieldContainer.dataset.key = key; // Add data-key for CSS grid targeting

                const label = document.createElement('label');
                label.htmlFor = `edit-${key.replace(/[^a-zA-Z0-9]/g, '-')}`;
                
                // Use more descriptive labels
                const fieldLabels = {
                    'docId': 'Document ID',
                    'id': 'Tile ID'
                };
                label.textContent = fieldLabels[key] || key;

                const description = TILE_FIELD_DESCRIPTIONS[key];
                if (description) {
                    const tooltipSpan = document.createElement('span');
                    tooltipSpan.className = 'tooltip-icon';
                    tooltipSpan.textContent = '(?)';
                    tooltipSpan.title = description;
                    label.appendChild(tooltipSpan);
                }

                // Skip creating a direct field for Overrides (JSON)
                if (key === 'Overrides (JSON)') return;

                const posKeys = ['Left (%)', 'Top (%)', 'Width (%)', 'Height (%)'];
                if (posKeys.includes(key)) {
                    const compound = document.createElement('div');
                    compound.className = 'form-field-compound';
                    const rangeInput = document.createElement('input');
                    rangeInput.type = 'range';
                    rangeInput.min = 0; rangeInput.max = 100; rangeInput.step = 0.01;
                    rangeInput.dataset.sync = key;
                    const textInput = document.createElement('input');
                    textInput.type = 'text';
                    textInput.name = key;
                    textInput.dataset.sync = key;
                    compound.append(rangeInput, textInput);
                    fieldContainer.appendChild(compound);
                } else if (key === 'Rotation') {
                    const compound = document.createElement('div');
                    compound.className = 'form-field-compound';
                    const rangeInput = document.createElement('input');
                    rangeInput.type = 'range';
                    rangeInput.min = 0; rangeInput.max = 360; rangeInput.step = 1;
                    rangeInput.dataset.sync = key;
                    const textInput = document.createElement('input');
                    textInput.type = 'text';
                    textInput.name = key;
                    textInput.dataset.sync = key;
                    compound.append(rangeInput, textInput);
                    fieldContainer.appendChild(compound);
                } else if (key.toLowerCase().includes('description')) {
                    const textarea = document.createElement('textarea');
                    textarea.id = `edit-${key.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    textarea.name = key;
                    textarea.title = key;
                    fieldContainer.appendChild(textarea);
                } else {
                    if (key === 'Prerequisites') { // Make prerequisites a collapsible fieldset
                        const prereqFieldset = document.createElement('fieldset');
                        prereqFieldset.className = 'overrides-fieldset minimized';
                        prereqFieldset.id = 'prereq-editor-container';
                        const prereqLegend = document.createElement('legend');
                        prereqLegend.innerHTML = `<span class="legend-toggle">[+]</span>Prerequisites`;
                        prereqLegend.style.cursor = 'pointer';
                        prereqLegend.onclick = () => {
                            prereqFieldset.classList.toggle('minimized');
                            prereqLegend.querySelector('.legend-toggle').textContent = prereqFieldset.classList.contains('minimized') ? '[+]' : '[-]';
                        };
                        prereqFieldset.appendChild(prereqLegend);
                        const prereqContent = document.createElement('div');
                        prereqContent.className = 'fieldset-content';
                        const textarea = document.createElement('textarea');
                        textarea.id = `edit-${key.replace(/[^a-zA-Z0-9]/g, '-')}`;
                        textarea.name = key;
                        textarea.title = key;
                        textarea.style.display = 'none'; // Hide the raw textarea, UI will populate it
                        const uiContainer = document.createElement('div');
                        uiContainer.id = 'prereq-ui-container';
                        const addGroupBtn = document.createElement('button');
                        addGroupBtn.type = 'button';
                        addGroupBtn.textContent = '+ Add OR Group';
                        addGroupBtn.onclick = () => { addPrereqOrGroup(); updatePrereqJson(); };
                        prereqContent.append(textarea, uiContainer, addGroupBtn);
                        prereqFieldset.appendChild(prereqContent);
                        fieldContainer.appendChild(prereqFieldset);
                        fieldContainer.prepend(label);
                        detailsForm.appendChild(fieldContainer);
                        return; // Skip default input creation
                    }
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.id = `edit-${key.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    input.name = key;
                    input.title = key;
                    if (key === 'docId') {
                        input.disabled = true; // Make Document ID read-only
                    }
                    fieldContainer.appendChild(input);
                }

                fieldContainer.prepend(label);
                detailsForm.appendChild(fieldContainer);
            });

            // Create a dedicated section for overrides
            const fieldset = document.createElement('fieldset');
            fieldset.className = 'overrides-fieldset';
            fieldset.style.gridColumn = '1 / -1'; // Ensure it spans full width

            const legend = document.createElement('legend');
            legend.textContent = 'Overrides';
            
            const rawJsonTextarea = document.createElement('textarea');
            rawJsonTextarea.id = 'overrides-json-textarea';
            rawJsonTextarea.placeholder = 'Manually edit overrides as a nested JSON object here. Changes will reflect in the UI below.';

            const overridesContainer = document.createElement('div');
            overridesContainer.id = 'overrides-container';

            const addOverrideBtn = document.createElement('button');
            addOverrideBtn.type = 'button';
            addOverrideBtn.id = 'add-override-btn';
            addOverrideBtn.textContent = '+ Add Override';
            addOverrideBtn.disabled = true;

            fieldset.append(legend, rawJsonTextarea, overridesContainer, addOverrideBtn);
            detailsForm.appendChild(fieldset);

            // Add listeners after appending
            addOverrideBtn.addEventListener('click', () => addOverrideRow());
            rawJsonTextarea.addEventListener('input', handleRawJsonOverrideChange);
        }

        function updateEditorPanel(index) {
            const activeElement = document.activeElement;
            const overridesContainer = document.getElementById('overrides-container');

            // --- Capture state for overrides section before it's rebuilt ---
            let activeOverrideState = null;
            if (activeElement && overridesContainer.contains(activeElement)) {
                const overrideItem = activeElement.closest('.override-item');
                if (overrideItem) {
                    // Find the index of this item to use as a stable identifier
                    const itemIndex = Array.from(overridesContainer.children).indexOf(overrideItem);
                    activeOverrideState = {
                        itemIndex: itemIndex,
                        isKeyField: activeElement.classList.contains('override-key'),
                        isValueField: activeElement.classList.contains('override-value'),
                        value: activeElement.value,
                        selectionStart: activeElement.selectionStart,
                        selectionEnd: activeElement.selectionEnd
                    };
                }
            }


            if (index === null || !tilesData[index]) {
                lastSelectedTileIndex = null;
                deleteTileBtn.disabled = true;
                document.getElementById('add-override-btn').disabled = true;
                Array.from(detailsForm.elements).forEach(el => {
                    el.disabled = true;
                    el.value = '';
                });
                // Clear validation message when no tile is selected
                const idInput = detailsForm.querySelector('input[name="id"]');
                if (idInput) {
                    idInput.style.borderColor = '';
                    const validationMessage = idInput.closest('.form-field')?.querySelector('.validation-msg');
                    if (validationMessage) validationMessage.textContent = '';
                }
                renderPrereqLines();
                return;
            }
            
            lastSelectedTileIndex = index;
            const tile = tilesData[index];

            Array.from(detailsForm.elements).forEach(el => {
                // Keep the docId field disabled, as it should never be edited.
                if (el.name !== 'docId') {
                    el.disabled = false;
                }
            });
            document.getElementById('add-override-btn').disabled = false;
            deleteTileBtn.disabled = false;

            // Populate the form
            TILE_FIELDS.forEach(key => {
                // Skip the raw overrides field
                if (key === 'Overrides (JSON)') return;

                const input = detailsForm.elements[key];
                const syncElements = detailsForm.querySelectorAll(`[data-sync="${key}"]`);

                // --- Prevent overwriting a field the user is actively editing ---
                let isEditingThisField = (input === activeElement);
                syncElements.forEach(el => { if (el === activeElement) isEditingThisField = true; });
                if (isEditingThisField) {
                    return; // Skip populating this field
                }
                // --- End prevention logic ---

                if (syncElements.length > 0) {
                    const value = tile[key] || '';
                    syncElements.forEach(el => {
                        if (key === 'Rotation' && el.type === 'range') {
                            el.value = parseFloat(value) || 0;
                        } else {
                            el.value = value;
                        }
                    });
                } else if (input) {
                    input.value = tile[key] || '';
                }
            });

            // Populate the prerequisites UI
            const prereqTextarea = detailsForm.elements['Prerequisites'];
            if (prereqTextarea) {
                const prereqValue = tile['Prerequisites'] || '';
                prereqTextarea.value = prereqValue;
                populatePrereqUI(prereqValue);
            }

            // Populate the overrides section
            let overrides = {};
            try {
                if (tile['Overrides (JSON)']) {
                    overrides = JSON.parse(tile['Overrides (JSON)']);
                }
            } catch (e) { /* Ignore invalid JSON */ }

            // Update the raw JSON textarea
            const rawJsonTextarea = document.getElementById('overrides-json-textarea');
            if (rawJsonTextarea) {
                rawJsonTextarea.value = tile['Overrides (JSON)'] ? JSON.stringify(overrides, null, 2) : '';
                rawJsonTextarea.style.borderColor = ''; // Reset validation on load
            }
            // Populate the UI from the parsed JSON
            populateOverridesUI(overrides);

            // --- Restore state for overrides section ---
            if (activeOverrideState) {
                const allOverrideItems = overridesContainer.querySelectorAll('.override-item');
                const targetItem = allOverrideItems[activeOverrideState.itemIndex];
                if (targetItem) {
                    let elementToFocus = null;
                    if (activeOverrideState.isKeyField) {
                        elementToFocus = targetItem.querySelector('.override-key');
                    } else if (activeOverrideState.isValueField) {
                        elementToFocus = targetItem.querySelector('.override-value');
                    }

                    if (elementToFocus) {
                        elementToFocus.value = activeOverrideState.value;
                        elementToFocus.focus();
                        try {
                            elementToFocus.setSelectionRange(activeOverrideState.selectionStart, activeOverrideState.selectionEnd);
                        } catch (e) { /* no-op */ }
                    }
                }
            }

            // Sync the tile selector dropdown
            const selector = document.getElementById('tile-selector-dropdown');
            if (selector) {
                selector.value = index !== null ? index : '';
            }

            validateTileId();
            renderPrereqLines();
        }

        function populateTileSelector() {
            const selector = document.getElementById('tile-selector-dropdown');
            if (!selector) return;

            // Sort tiles by ID for a consistent order
            const sortedTiles = [...tilesData].sort((a, b) => (a.id || '').localeCompare(b.id || ''));

            selector.innerHTML = '<option value="">-- Select a Tile by ID --</option>';
            sortedTiles.forEach(tile => {
                const originalIndex = tilesData.findIndex(t => t.docId === tile.docId);
                const option = document.createElement('option');
                option.value = originalIndex;
                option.textContent = `${tile.id || '[No ID]'} - ${tile.Name || '[No Name]'}`;
                selector.appendChild(option);
            });

            // Set the selected option based on the currently selected tile
            if (lastSelectedTileIndex !== null) {
                selector.value = lastSelectedTileIndex;
            } else {
                selector.value = '';
            }
        }

        function populateOverridesUI(overrides) {
            const container = document.getElementById('overrides-container');
            container.innerHTML = '';
            if (typeof overrides !== 'object' || overrides === null) return;

            for (const [status, properties] of Object.entries(overrides)) {
                if (typeof properties === 'object' && properties !== null) {
                    for (const [key, value] of Object.entries(properties)) {
                        addOverrideRow(status, key, value);
                    }
                }
            }
        }

        function populatePrereqUI(prereqString) {
            const uiContainer = document.getElementById('prereq-ui-container');
            if (!uiContainer) return;
            uiContainer.innerHTML = '';

            let orGroups = [];
            let isNewFormat = false;

            if (prereqString && prereqString.trim().startsWith('[')) {
                try {
                    const parsed = JSON.parse(prereqString);
                    if (Array.isArray(parsed) && (parsed.length === 0 || Array.isArray(parsed[0]))) {
                        orGroups = parsed;
                        isNewFormat = true;
                    }
                } catch (e) { /* Not valid JSON, treat as old format */ }
            }

            if (isNewFormat) {
                if (orGroups.length === 0) addPrereqOrGroup([]); // Show one empty box if it's an empty array `[]`
                else orGroups.forEach(andGroup => addPrereqOrGroup(andGroup));
            } else {
                // Old format (e.g., "A1,A2") or invalid. Show as a single group.
                addPrereqOrGroup(prereqString ? prereqString.split(',') : []);
            }
        }

        function addPrereqOrGroup(andConditions = []) {
            const uiContainer = document.getElementById('prereq-ui-container');
            if (!uiContainer) return;

            const groupDiv = document.createElement('div');
            groupDiv.className = 'prereq-or-group';

            const andInput = document.createElement('input');
            andInput.type = 'text';
            andInput.className = 'prereq-and-input';
            andInput.placeholder = 'Tile IDs to AND (e.g. A1, A2)';
            andInput.value = andConditions.map(s => String(s).trim()).filter(Boolean).join(', ');
            andInput.oninput = updatePrereqJson;

            const validationSpan = document.createElement('span');
            validationSpan.className = 'prereq-validation-msg';

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.textContent = '−';
            removeBtn.className = 'remove-override-btn'; // Re-use style
            removeBtn.style.marginTop = 0;
            removeBtn.onclick = () => {
                groupDiv.remove();
                updatePrereqJson();
                // After removing, re-label the "OR"s
                uiContainer.querySelectorAll('.prereq-or-label').forEach((label, index) => {
                    if (index > 0) label.style.display = 'block'; else label.style.display = 'none';
                });
            };

            const label = document.createElement('span');
            label.textContent = 'OR';
            label.className = 'prereq-or-label';
            if (uiContainer.children.length === 0) label.style.display = 'none';

            groupDiv.append(label, andInput, validationSpan, removeBtn);
            uiContainer.appendChild(groupDiv);
        }

        function getDuplicateIds(tiles) {
            if (!tiles) return new Set();
            const ids = tiles.map(t => t.id).filter(id => id); // Filter out empty/null IDs
            const duplicates = ids.filter((item, index) => ids.indexOf(item) !== index);
            return new Set(duplicates);
        }

        function validateTileId() {
            if (lastSelectedTileIndex === null) return;
            const tile = tilesData[lastSelectedTileIndex];
            const duplicateIds = getDuplicateIds(tilesData);
            const idInput = detailsForm.querySelector('input[name="id"]');
            if (!idInput) return;

            const parentField = idInput.closest('.form-field');
            if (!parentField) return;

            let validationMessage = parentField.querySelector('.validation-msg');
            if (!validationMessage) {
                validationMessage = document.createElement('span');
                validationMessage.className = 'validation-msg';
                parentField.appendChild(validationMessage);
            }

            if (duplicateIds.has(tile.id)) {
                idInput.style.borderColor = '#e57373';
                validationMessage.textContent = 'This Tile ID is not unique!';
            } else {
                idInput.style.borderColor = ''; // Reset
                validationMessage.textContent = '';
            }
        }

        function updatePrereqJson() {
            const uiContainer = document.getElementById('prereq-ui-container');
            const prereqTextarea = detailsForm.elements['Prerequisites'];
            if (!uiContainer || !prereqTextarea) return;

            const validIds = new Set(tilesData.map(t => t.id));

            const orGroups = Array.from(uiContainer.querySelectorAll('.prereq-or-group')).map(groupDiv => {
                const input = groupDiv.querySelector('.prereq-and-input');
                const validationSpan = groupDiv.querySelector('.prereq-validation-msg');
                const ids = input.value.split(',').map(s => s.trim()).filter(Boolean);

                const invalidIds = ids.filter(id => !validIds.has(id));
                if (invalidIds.length > 0) {
                    validationSpan.textContent = `Invalid IDs: ${invalidIds.join(', ')}`;
                    input.style.borderColor = '#e57373';
                } else {
                    validationSpan.textContent = '';
                    input.style.borderColor = '';
                }

                return ids;
            }).filter(group => group.length > 0);

            if (orGroups.length === 0) prereqTextarea.value = '';
            else if (orGroups.length === 1) prereqTextarea.value = orGroups[0].join(',');
            else prereqTextarea.value = JSON.stringify(orGroups);
            prereqTextarea.dispatchEvent(new Event('input', { bubbles: true }));

            // Also re-render the lines to show live feedback
            renderPrereqLines();
        }

        function addOverrideRow(status = '', key = '', value = '') {
            const container = document.getElementById('overrides-container');
            const item = document.createElement('div');
            item.className = 'override-item';

            // 1. Status Dropdown
            const statusSelect = document.createElement('select');
            statusSelect.className = 'override-status-select';
            statusSelect.innerHTML = `<option value="">Select Status</option>`;
            STATUSES.forEach(s => {
                statusSelect.innerHTML += `<option value="${s}" ${s === status ? 'selected' : ''}>${s}</option>`;
            });

            // 2. Property Dropdown
            const keySelect = document.createElement('select');
            keySelect.className = 'override-key';
            keySelect.innerHTML = `<option value="">Select Property</option>`;
            VALID_OVERRIDE_PROPERTIES.forEach(prop => {
                const option = document.createElement('option');
                option.value = prop;
                option.textContent = prop;
                keySelect.appendChild(option);
            });
            keySelect.value = key;

            // 3. Value Input Container
            const valueContainer = document.createElement('div');
            valueContainer.className = 'override-value-container';

            // 4. Remove Button
            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'remove-override-btn';
            removeBtn.textContent = '−';

            item.append(statusSelect, keySelect, valueContainer, removeBtn);
            container.appendChild(item);

            // Add listeners
            const updateCallback = () => updateOverridesJsonFromCurrentTile();
            statusSelect.addEventListener('change', updateCallback);
            keySelect.addEventListener('change', () => {
                populateValueContainer(valueContainer, keySelect.value, '');
                updateCallback();
            });
            valueContainer.addEventListener('input', updateCallback);

            populateValueContainer(valueContainer, key, value);

            removeBtn.addEventListener('click', () => {
                item.remove();
                updateCallback();
            });
        }

        function populateValueContainer(container, propertyName, value) {
            container.innerHTML = ''; // Clear previous input

            const isColor = propertyName.toLowerCase().includes('color');
            const isOpacity = propertyName === 'opacity';
            const isShape = propertyName === 'shape';
            const isBoolean = propertyName === 'useStampByDefault';
            const isWidth = propertyName.toLowerCase().includes('width');
            const isScale = propertyName === 'stampScale';
            const isImage = propertyName === 'stampImageUrl';

            let inputHtml = '';

            if (isShape) {
                const options = styleSchema.shape.options.map(opt => `<option value="${opt}" ${value === opt ? 'selected' : ''}>${opt}</option>`).join('');
                inputHtml = `<select class="override-value"><option value="">Default</option>${options}</select>`;
            } else if (isColor) {
                // NEW: Use DOM creation for color inputs to add sync listeners
                const compoundDiv = document.createElement('div');
                compoundDiv.className = 'form-field-compound';

                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.value = value || '#000000';

                const textInput = document.createElement('input');
                textInput.type = 'text';
                textInput.className = 'override-value color-text-input'; // This one has the class to be picked up
                textInput.value = value || '#000000';

                colorInput.addEventListener('change', (e) => {
                    textInput.value = e.target.value;
                    textInput.dispatchEvent(new Event('input', { bubbles: true }));
                });
                textInput.addEventListener('input', (e) => {
                    let potentialColor = e.target.value;
                    if (/^[0-9A-F]{6}$/i.test(potentialColor) || /^[0-9A-F]{3}$/i.test(potentialColor)) {
                        potentialColor = '#' + potentialColor;
                        e.target.value = potentialColor; // FIX: Update the text input's value so it's saved correctly
                    }
                    colorInput.value = potentialColor;
                });

                compoundDiv.append(colorInput, textInput);
                container.appendChild(compoundDiv);
                return; // Exit early
            } else if (isWidth) {
                inputHtml = `<div class="form-field-compound">
                                <input type="number" class="override-value" value="${parseFloat(value) || 0}" data-unit="px" min="0" max="20" step="1">
                                <span style="margin-left: 5px;">px</span>
                             </div>`;
            } else if (isOpacity || isScale) {
                const schema = isOpacity ? { min: 0, max: 1, step: 0.01 } : styleSchema.stampScale;
                inputHtml = `<div class="form-field-compound">
                                <input type="range" class="override-value" value="${value || schema.min}" min="${schema.min}" max="${schema.max}" step="${schema.step}">
                                <span style="width: 40px; text-align: left;">${value || schema.min}</span>
                             </div>`;
            } else if (isBoolean) {
                const isTrue = value === true || String(value).toLowerCase() === 'true';
                const isFalse = value === false || String(value).toLowerCase() === 'false';
                inputHtml = `<select class="override-value">
                                <option value="">Default</option>
                                <option value="true" ${isTrue ? 'selected' : ''}>True</option>
                                <option value="false" ${isFalse ? 'selected' : ''}>False</option>
                             </select>`;
            } else if (isImage) {
                // For this case, we build the DOM directly to attach the event listener
                const compoundDiv = document.createElement('div');
                compoundDiv.className = 'form-field-compound';

                const textInput = document.createElement('input');
                textInput.type = 'text';
                textInput.className = 'override-value';
                textInput.placeholder = 'Image URL';
                textInput.value = value || '';
                textInput.style.flexGrow = '1';

                const fileInputId = `override-upload-${Date.now()}-${Math.random()}`;
                const uploadLabel = document.createElement('label');
                uploadLabel.htmlFor = fileInputId;
                uploadLabel.className = 'button-like-label';
                uploadLabel.textContent = 'Upload';

                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.id = fileInputId;
                fileInput.style.display = 'none';
                fileInput.dataset.path = 'overrides/stamps/';
                fileInput.addEventListener('change', (e) => handleOverrideImageUpload(e.target, textInput));

                compoundDiv.append(textInput, uploadLabel, fileInput);
                container.appendChild(compoundDiv);
                return; // Exit early
            } else { // Default text input for things like stampRotation, stampPosition
                inputHtml = `<input type="text" class="override-value" value="${value || ''}">`;
            }

            container.innerHTML = inputHtml;

            const rangeInput = container.querySelector('input[type="range"]');
            if (rangeInput) {
                rangeInput.addEventListener('input', (e) => {
                    e.target.nextElementSibling.textContent = e.target.value;
                });
            }
        }

        function handleRawJsonOverrideChange(event) {
            const textarea = event.target;
            try {
                const jsonString = textarea.value;
                if (jsonString.trim() === '') {
                    populateOverridesUI({});
                    updateOverridesJsonFromCurrentTile(); // This will save the empty string
                    textarea.style.borderColor = '';
                    return;
                }
                const parsedOverrides = JSON.parse(jsonString);
                populateOverridesUI(parsedOverrides);
                updateOverridesJsonFromCurrentTile(); // This will re-format and save
                textarea.style.borderColor = ''; // Valid JSON
            } catch (e) {
                textarea.style.borderColor = '#e57373'; // Invalid JSON
            }
        }

        function handleEditorInputChange(event) {
            if (lastSelectedTileIndex === null) return;

            const input = event.target;
            if (!input.closest('.override-item') && !input.closest('#prereq-editor-container')) {
                updateMainTileData(input);
            }
        }

        function updateMainTileData(input) {
            const index = lastSelectedTileIndex;
            if (index === null) return;
            const tile = tilesData[index];
            const key = input.dataset.sync || input.name;
            const oldValue = tile[key]; // Get old value before any changes
            let value = input.value;

            // Handle Rotation slider specifically to add 'deg'
            if (key === 'Rotation' && input.type === 'range') {
                value = `${value}deg`;
            }

            // If a synced input changes, update the others
            const syncName = input.dataset.sync;
            if (syncName) {
                detailsForm.querySelectorAll(`[data-sync="${syncName}"]`).forEach(el => {
                    if (el !== input) {
                        // When updating the rotation slider from the text input
                        if (syncName === 'Rotation' && el.type === 'range') {
                            el.value = parseFloat(value) || 0;
                        } else {
                            el.value = value;
                        }
                    }
                });
            }
            
            tile[key] = value;
            
            // Auto-save the change
            debouncedSaveTile(tile.docId, { [key]: value }, input, oldValue);
            
            // If a visual property was changed, update the visual tile
            const visualKeys = ['id', 'Name', 'Rotation', 'Left (%)', 'Top (%)', 'Width (%)', 'Height (%)'];
            if (visualKeys.includes(key)) {
                renderTiles();
            }
            if (key === 'Prerequisites') {
                renderPrereqLines();
            }
            // NEW: Validate ID on change
            if (key === 'id') {
                validateTileId();
            }
        }

        const debouncedUpdateOverrides = debounce(() => {
            if (lastSelectedTileIndex === null) return;
            const index = lastSelectedTileIndex;

            const overrides = {};
            document.querySelectorAll('#overrides-container .override-item').forEach(item => {
                const status = item.querySelector('.override-status-select').value;
                const key = item.querySelector('.override-key').value;
                const valueContainer = item.querySelector('.override-value-container');

                if (status && key && valueContainer.hasChildNodes()) {
                    const inputElement = valueContainer.querySelector('.override-value');
                    if (!inputElement) return;

                    let value;
                    if (inputElement.type === 'checkbox') { value = inputElement.checked; }
                    else { value = inputElement.value; }

                    if (inputElement.dataset.unit) {
                        value += inputElement.dataset.unit;
                    }

                    if (inputElement.tagName === 'SELECT' && value === '') return;

                    if (!overrides[status]) overrides[status] = {};

                    if (value === 'true') { overrides[status][key] = true; }
                    else if (value === 'false') { overrides[status][key] = false; }
                    else { overrides[status][key] = value; }
                }
            });

            const newOverridesJson = Object.keys(overrides).length > 0 ? JSON.stringify(overrides, null, 2) : '';
            document.getElementById('overrides-json-textarea').value = newOverridesJson;
            tilesData[index]['Overrides (JSON)'] = newOverridesJson;
            debouncedSaveTile(tilesData[index].docId, { 'Overrides (JSON)': newOverridesJson });
            renderTiles();
        }, 500);

        function updateOverridesJsonFromCurrentTile() {
            debouncedUpdateOverrides();
        }

        function addNewTile() {
            // Find the highest existing numeric docId to create the next one.
            const existingNumbers = tilesData.map(t => parseInt(t.docId, 10)).filter(n => !isNaN(n));
            const maxNumber = existingNumbers.length > 0 ? Math.max(...existingNumbers) : 0;
            const newDocId = String(maxNumber + 1).padStart(5, '0');

            const newTileData = {
                id: newDocId, // The visible ID defaults to the doc ID
                Name: 'New Tile',
                'Left (%)': '45.00',
                'Top (%)': '45.00',
                'Width (%)': '10.00',
                'Height (%)': '10.00',
                // Initialize other fields to empty strings to avoid 'undefined' issues
                Points: '',
                Description: '',
                Prerequisites: '',
                Rotation: '',
                'Overrides (JSON)': ''
            };

            // Save the new tile to Firestore
            fb.setDoc(fb.doc(db, 'tiles', newDocId), newTileData)
                .then(() => {
                    showMessage(`Tile ${newDocId} created successfully.`, false);
                    // The onSnapshot listener will automatically add the new tile to the UI.
                })
                .catch(err => showMessage(`Failed to create tile: ${err.message}`, true));
        }

        function deleteSelectedTile() {
            if (lastSelectedTileIndex === null) return;
            const tileToDelete = tilesData[lastSelectedTileIndex];
            if (confirm(`Are you sure you want to delete tile "${tileToDelete.id}"?`)) {
                fb.deleteDoc(fb.doc(db, 'tiles', tileToDelete.docId)).then(() => {
                    showMessage(`Tile ${tileToDelete.id} deleted.`, false);
                    // The onSnapshot listener will automatically handle removing the tile
                    // from the UI and clearing the editor panel if it was selected.
                }).catch(err => showMessage(`Failed to delete tile: ${err.message}`, true));
            }
        }

        // --- NEW: Mass Deletion Logic ---
        function openDeleteAllModal() {
            document.getElementById('delete-all-modal').style.display = 'flex';
        }

        function closeDeleteAllModal() {
            const modal = document.getElementById('delete-all-modal');
            modal.style.display = 'none';
            document.getElementById('delete-confirm-input').value = '';
            document.getElementById('delete-confirm-btn').disabled = true;
        }

        function validateDeleteAll() {
            const input = document.getElementById('delete-confirm-input');
            const confirmBtn = document.getElementById('delete-confirm-btn');
            confirmBtn.disabled = input.value !== 'DELETE ALL';
        }

        async function executeDeleteAll() {
            showGlobalLoader();
            const confirmBtn = document.getElementById('delete-confirm-btn');
            confirmBtn.disabled = true;
            confirmBtn.textContent = 'Deleting...';

            try {
                const batch = fb.writeBatch(db);
                tilesData.forEach(tile => batch.delete(fb.doc(db, 'tiles', tile.docId)));
                await batch.commit();
                showMessage('All tiles have been deleted.', false);
                closeDeleteAllModal();
            } catch (error) {
                showMessage(`Error deleting tiles: ${error.message}`, true);
            } finally {
                confirmBtn.textContent = 'Confirm Deletion';
                hideGlobalLoader();
            }
        }

        async function syncPublicLayout() {
            if (!confirm('This will overwrite the public tile layout data with the current layout, points, and prerequisites. Are you sure?')) return;
            showGlobalLoader();
            showMessage('Starting public layout sync...', false);

            // Fields that are safe to be public. Name, Description, and Overrides are excluded.
            const publicFields = ['id', 'Points', 'Prerequisites', 'Left (%)', 'Top (%)', 'Width (%)', 'Height (%)', 'Rotation'];

            try {
                // Step 1: Get all current public tiles to delete them.
                // This ensures that tiles deleted from the main board are also removed from the public view.
                const publicTilesSnapshot = await fb.getDocs(fb.collection(db, 'public_tiles'));
                
                // Step 2: Create a new batch write operation.
                const batch = fb.writeBatch(db);

                // Step 3: Schedule all old public documents for deletion.
                publicTilesSnapshot.docs.forEach(doc => {
                    batch.delete(doc.ref);
                });

                // Step 4: Schedule new public documents to be created from the main `tilesData`.
                tilesData.forEach(tile => {
                    const publicData = {};
                    publicFields.forEach(field => {
                        if (tile[field] !== undefined) {
                            publicData[field] = tile[field];
                        }
                    });
                    // Use the same document ID for consistency between collections.
                    const publicTileRef = fb.doc(db, 'public_tiles', tile.docId);
                    batch.set(publicTileRef, publicData);
                });

                // Step 5: Commit the entire batch operation.
                await batch.commit();
                showMessage('Public layout synced successfully!', false);
            } catch (error) {
                showMessage(`Sync failed: ${error.message}`, true);
                console.error('Public layout sync error:', error);
            } finally {
                hideGlobalLoader();
            }
        }

        detailsForm.addEventListener('input', handleEditorInputChange);
        document.getElementById('global-style-form').addEventListener('input', handleGlobalStyleInputChange);
        addNewTileBtn.addEventListener('click', addNewTile);
        deleteTileBtn.addEventListener('click', deleteSelectedTile);
        toggleTeamsBtn.addEventListener('click', toggleTeams);
        toggleGlobalStylesBtn.addEventListener('click', toggleGlobalStyles);

        prereqVisModeSelect.addEventListener('change', (event) => {
            prereqVisMode = event.target.value;
            renderPrereqLines();
        });

        boardContent.addEventListener('click', (event) => {
            // Don't open modal if the user is dragging/resizing with interact.js
            if (event.target.classList.contains('interact-resizing') || event.target.classList.contains('interact-dragging')) {
                return;
            }
            const tileEl = event.target.closest('.draggable-tile');
            if (tileEl) {
                const index = parseInt(tileEl.dataset.index, 10);
                updateEditorPanel(index);
            }
        });

        function toggleGlobalStyles() {
            const form = document.getElementById('global-style-form');
            const isHidden = form.style.display === 'none';
            form.style.display = isHidden ? '' : 'none';
            toggleGlobalStylesBtn.textContent = isHidden ? '-' : '+';
        }

        function toggleTeams() {
            const form = document.getElementById('teams-form');
            const isHidden = form.style.display === 'none';
            form.style.display = isHidden ? '' : 'none';
            toggleTeamsBtn.textContent = isHidden ? '-' : '+';
        }
        // --- Global Style Editor Logic ---
        function renderGlobalConfig() {
            const form = document.getElementById('global-style-form');

            // Preserve focus and value of the active input to prevent losing work during live updates.
            let activeElementKey = null;
            let activeElementValue = null;
            let selectionStart = null;
            let selectionEnd = null;
            const activeElement = document.activeElement;
            if (activeElement && form.contains(activeElement) && activeElement.dataset.key) {
                activeElementKey = activeElement.dataset.key;
                activeElementValue = activeElement.value;
                selectionStart = activeElement.selectionStart;
                selectionEnd = activeElement.selectionEnd;
            }


            // Preserve the expansion state of each fieldset before clearing the form
            const expansionStates = {};
            form.querySelectorAll('fieldset').forEach(fs => {
                const legend = fs.querySelector('legend');
                if (legend) {
                    // Use the group name as a stable key
                    const groupName = legend.textContent.replace(/\[[+-]\]\s*/, '').trim();
                    expansionStates[groupName] = !fs.classList.contains('minimized');
                }
            });

            form.innerHTML = ''; // Now clear existing content

            Object.entries(configGroups).forEach(([groupName, properties]) => {
                const fieldset = document.createElement('fieldset');
                const isExpanded = expansionStates[groupName] === true;
                fieldset.className = `overrides-fieldset ${isExpanded ? '' : 'minimized'}`;

                const legend = document.createElement('legend');
                legend.innerHTML = `<span class="legend-toggle">[${isExpanded ? '-' : '+'}]</span>${groupName}`;
                fieldset.appendChild(legend);

                legend.addEventListener('click', () => {
                    fieldset.classList.toggle('minimized');
                    const toggle = legend.querySelector('.legend-toggle');
                    toggle.textContent = fieldset.classList.contains('minimized') ? '[+]' : '[-]';
                }); 

                const fieldsetContent = document.createElement('div');
                fieldsetContent.className = 'fieldset-content config-grid';

                properties.forEach(prop => { 
                    const schema = configSchema[prop];
                    if (!schema) return;

                    const value = config[prop] ?? (schema.type === 'boolean' ? false : '');

                    const fieldContainer = document.createElement('div');
                    fieldContainer.className = 'form-field';
                    const label = document.createElement('label');
                    label.textContent = schema.label;
                    fieldContainer.appendChild(label);

                    if (schema.description) {
                        const tooltipSpan = document.createElement('span');
                        tooltipSpan.className = 'tooltip-icon';
                        tooltipSpan.textContent = '(?)';
                        tooltipSpan.title = schema.description;
                        label.appendChild(tooltipSpan);
                    }


                    let inputHtml = '';
                    switch(schema.type) {
                        case 'image':
                            const fileInputId_global = `file-upload-${prop}-global`;
                            inputHtml = `<div class="form-field-compound">
                                            <input type="text" class="config-input" data-key="${prop}" value="${value}" placeholder="Image URL" style="flex-grow: 1;">
                                            <label for="${fileInputId_global}" class="button-like-label">Upload</label>
                                            <input type="file" id="${fileInputId_global}" data-key="${prop}" data-path="${schema.path}" style="display: none;">
                                         </div>
                                         <img src="${value}" class="image-upload-preview" style="${!value ? 'display:none;' : ''}">`;
                            break;
                        case 'textarea':
                            inputHtml = `<textarea class="config-input" data-key="${prop}">${value}</textarea>`;
                            break;
                        case 'boolean':
                            const checked = value === true;
                            if (prop === 'censorTilesBeforeEvent') {
                                const checkboxHtml = `<input type="checkbox" class="config-input" data-key="${prop}" ${checked ? 'checked' : ''}>`;
                                const buttonHtml = `<button type="button" id="sync-public-layout-btn" style="margin-left: auto; margin-top: 0;" title='If "Censor Tiles Pre-Event" is active, the player board will show a censored version of the tiles from a separate \`public_tiles\` collection. After making changes to the board layout, points, or prerequisites, you must sync the data for non-admins to see the updates.'>Sync Public Layout</button>`;
                                inputHtml = `<div style="display: flex; align-items: center; width: 100%;">${checkboxHtml}${buttonHtml}</div>`;
                            } else {
                                inputHtml = `<input type="checkbox" class="config-input" data-key="${prop}" ${checked ? 'checked' : ''}>`;
                            }
                            break;
                        case 'select':
                            const options = schema.options.map(opt => `<option value="${opt}" ${value === opt ? 'selected' : ''}>${opt}</option>`).join('');
                            inputHtml = `<select class="config-input" data-key="${prop}">${options}</select>`;
                            break;
                        case 'color':
                            inputHtml = `<input type="color" class="config-input" data-key="${prop}" value="${value}">`;
                            break;
                        case 'range':
                            inputHtml = `<input type="range" class="config-input" data-key="${prop}" value="${value}" min="${schema.min}" max="${schema.max}" step="${schema.step}">
                                         <span>${value}</span>`; // Show value next to slider
                            break;
                        case 'text':
                        default:
                            inputHtml = `<input type="text" class="config-input" data-key="${prop}" value="${value}">`;
                            break;
                    }
                    fieldContainer.innerHTML += inputHtml;
                    fieldsetContent.appendChild(fieldContainer);
                });

                fieldset.appendChild(fieldsetContent);
                form.appendChild(fieldset);
            });

            // NEW: Render fieldsets for each status style
            STATUSES.forEach(status => {
                const groupName = `Status Styles (${status})`;
                const fieldset = document.createElement('fieldset');
                const isExpanded = expansionStates[groupName] === true;
                fieldset.className = `overrides-fieldset ${isExpanded ? '' : 'minimized'}`;

                const legend = document.createElement('legend');
                legend.innerHTML = `<span class="legend-toggle">[${isExpanded ? '-' : '+'}]</span>${groupName}`;
                fieldset.appendChild(legend);

                legend.addEventListener('click', () => {
                    fieldset.classList.toggle('minimized');
                    const toggle = legend.querySelector('.legend-toggle');
                    toggle.textContent = fieldset.classList.contains('minimized') ? '[+]' : '[-]';
                });

                const fieldsetContent = document.createElement('div');
                fieldsetContent.className = 'fieldset-content config-grid';

                // Render non-stamp properties
                Object.entries(styleSchema).forEach(([prop, schema]) => {
                    if (prop.startsWith('stamp')) return; // Skip stamp properties for now
                    renderStyleProperty(fieldsetContent, status, prop, schema);
                });

                // --- Create the collapsible stamp fieldset ---
                const useStampValue = allStyles[status]?.useStampByDefault === true;
                const stampFieldset = document.createElement('fieldset');
                stampFieldset.className = `overrides-fieldset stamp-fieldset ${useStampValue ? '' : 'minimized'}`;

                const stampLegend = document.createElement('legend');
                const useStampSchema = styleSchema.useStampByDefault;
                const useStampLabel = document.createElement('label');
                const useStampCheckbox = document.createElement('input');
                useStampCheckbox.type = 'checkbox';
                useStampCheckbox.className = 'config-input';
                useStampCheckbox.dataset.status = status;
                useStampCheckbox.dataset.key = 'useStampByDefault';
                useStampCheckbox.checked = useStampValue;
                const useStampLabelText = document.createTextNode(` ${useStampSchema.label}`);
                useStampLabel.append(useStampCheckbox, useStampLabelText);
                if (useStampSchema.description) {
                    const tooltip = Object.assign(document.createElement('span'), { className: 'tooltip-icon', textContent: '(?)', title: useStampSchema.description });
                    useStampLabel.appendChild(tooltip);
                }
                stampLegend.appendChild(useStampLabel);
                stampFieldset.appendChild(stampLegend);

                const stampFieldsetContent = document.createElement('div');
                stampFieldsetContent.className = 'fieldset-content';
                Object.entries(styleSchema).forEach(([prop, schema]) => {
                    if (prop.startsWith('stamp') && prop !== 'useStampByDefault') {
                        renderStyleProperty(stampFieldsetContent, status, prop, schema);
                    }
                });
                stampFieldset.appendChild(stampFieldsetContent);
                useStampCheckbox.addEventListener('change', e => stampFieldset.classList.toggle('minimized', !e.target.checked));
                fieldsetContent.appendChild(stampFieldset);
                // --- End stamp fieldset ---

                fieldset.appendChild(fieldsetContent);
                form.appendChild(fieldset);
            });

            // Restore focus and value to the previously active element
            if (activeElementKey) {
                const newActiveElement = form.querySelector(`[data-key="${activeElementKey}"]`);
                if (newActiveElement) {
                    newActiveElement.value = activeElementValue; // Restore the unsaved value the user was typing
                    newActiveElement.focus();
                    try { // Setting selection can fail on some input types (e.g., color)
                        newActiveElement.setSelectionRange(selectionStart, selectionEnd);
                    } catch (e) { /* no-op */ }
                }
            }

            // After the form is built, attach the listener for the sync button
            const syncBtn = document.getElementById('sync-public-layout-btn');
            if (syncBtn) {
                syncBtn.onclick = syncPublicLayout; // Safe to re-assign on re-renders
            }

            // Add event listeners for image uploads and range sliders
            form.querySelectorAll('input[type="file"]').forEach(input => { // This now targets the hidden file inputs
                input.addEventListener('change', (e) => {
                    // Stop the event from bubbling up to the form's 'input' listener,
                    // which prevents a race condition where the 'fakepath' gets saved.
                    e.stopPropagation();
                    handleImageUpload(e.target);
                });
            });
            form.querySelectorAll('input[type="range"]').forEach(input => {
                input.addEventListener('input', (e) => {
                    e.target.nextElementSibling.textContent = e.target.value;
                });
            });
        }

        function renderStyleProperty(parentContainer, status, prop, schema) {
            const value = allStyles[status]?.[prop] ?? (schema.type === 'boolean' ? false : '');

            const fieldContainer = document.createElement('div');
            fieldContainer.className = 'form-field';
            const label = document.createElement('label');
            label.textContent = schema.label;
            if (schema.description) {
                const tooltip = Object.assign(document.createElement('span'), { className: 'tooltip-icon', textContent: '(?)', title: schema.description });
                label.appendChild(tooltip);
            }
            fieldContainer.appendChild(label);

            let inputHtml = '';
            const dynamicPath = `${schema.path}${status.replace(/\s+/g, '_').toLowerCase()}`;

            switch(schema.type) {
                case 'image':
                    const fileInputId_style = `file-upload-${prop}-${status}`;
                    inputHtml = `<div class="form-field-compound">
                                    <input type="text" class="config-input" data-status="${status}" data-key="${prop}" value="${value}" placeholder="Image URL" style="flex-grow: 1;">
                                    <label for="${fileInputId_style}" class="button-like-label">Upload</label>
                                    <input type="file" id="${fileInputId_style}" data-status="${status}" data-key="${prop}" data-path="${dynamicPath}" style="display: none;">
                                 </div>
                                 <img src="${value}" class="image-upload-preview" style="${!value ? 'display:none;' : ''}">`;
                    break;
                case 'boolean':
                    inputHtml = `<input type="checkbox" class="config-input" data-status="${status}" data-key="${prop}" ${value ? 'checked' : ''}>`;
                    break;
                case 'range':
                        inputHtml = `<input type="range" class="config-input" data-status="${status}" data-key="${prop}" value="${value}" min="${schema.min}" max="${schema.max}" step="${schema.step}">
                                    <span>${value}</span>`;
                    break;
                case 'select':
                {
                    const options = schema.options.map(opt => `<option value="${opt}" ${value === opt ? 'selected' : ''}>${opt}</option>`).join('');
                    inputHtml = `<select class="config-input" data-status="${status}" data-key="${prop}">${options}</select>`;
                    break;
                }
                case 'numberWithUnit':
                {
                    const unit = schema.unit || '';
                    const currentValue = parseFloat(value) || 0;
                    inputHtml = `<div class="form-field-compound">
                                    <input type="number" class="config-input" data-status="${status}" data-key="${prop}" value="${currentValue}" min="${schema.min ?? 0}" max="${schema.max ?? 100}" step="${schema.step ?? 1}" data-unit="${unit}">
                                    <span style="width: 30px; text-align: left; margin-left: 5px;">${unit}</span>
                                    </div>`;
                    break;
                }
                case 'colorAndOpacity':
                {
                    const colorVal = allStyles[status]?.color ?? '#ffffff';
                    const opacityVal = allStyles[status]?.opacity ?? 0.5;
                    inputHtml = `<div class="form-field-compound" style="flex-direction: column; align-items: stretch; gap: 8px;">
                                    <div class="form-field-compound">
                                        <input type="color" data-status="${status}" data-key="color" value="${colorVal}">
                                        <input type="text" class="config-input color-text-input" data-status="${status}" data-key="color" value="${colorVal}">
                                    </div>
                                    <div class="form-field-compound">
                                        <input type="range" class="config-input" data-status="${status}" data-key="opacity" value="${opacityVal}" min="0" max="1" step="0.01">
                                        <span style="width: 40px; text-align: left; margin-left: 10px;">${opacityVal}</span>
                                    </div>
                                    </div>`;
                    break;
                    const mainDiv = document.createElement('div');
                    mainDiv.className = 'form-field-compound';
                    mainDiv.style.flexDirection = 'column'; mainDiv.style.alignItems = 'stretch'; mainDiv.style.gap = '8px';

                    const colorDiv = document.createElement('div');
                    colorDiv.className = 'form-field-compound';
                    const colorInput = Object.assign(document.createElement('input'), { type: 'color', value: colorVal, dataset: { status, key: 'color' } });
                    const textInput = Object.assign(document.createElement('input'), { type: 'text', className: 'config-input color-text-input', value: colorVal, dataset: { status, key: 'color' } });

                    colorInput.addEventListener('change', (e) => {
                        textInput.value = e.target.value;
                        textInput.dispatchEvent(new Event('input', { bubbles: true }));
                    });
                    textInput.addEventListener('input', (e) => {
                        let potentialColor = e.target.value;
                        if (/^[0-9A-F]{6}$/i.test(potentialColor) || /^[0-9A-F]{3}$/i.test(potentialColor)) {
                            potentialColor = '#' + potentialColor;
                            e.target.value = potentialColor;
                        }
                        colorInput.value = potentialColor;
                    });
                    colorDiv.append(colorInput, textInput);

                    const opacityDiv = document.createElement('div');
                    opacityDiv.className = 'form-field-compound';
                    const rangeInput = Object.assign(document.createElement('input'), { type: 'range', className: 'config-input', value: opacityVal, min: 0, max: 1, step: 0.01, dataset: { status, key: 'opacity' } });
                    const rangeSpan = Object.assign(document.createElement('span'), { textContent: opacityVal });
                    rangeSpan.style.cssText = 'width: 40px; text-align: left; margin-left: 10px;';
                    rangeInput.addEventListener('input', () => rangeSpan.textContent = rangeInput.value);
                    opacityDiv.append(rangeInput, rangeSpan);

                    mainDiv.append(colorDiv, opacityDiv);
                    fieldContainer.appendChild(mainDiv);
                    parentContainer.appendChild(fieldContainer);
                    return;
                }
                case 'widthAndColor':
                {
                    const widthKey = schema.keys.width;
                    const colorKey = schema.keys.color;
                    const unit = schema.unit || '';
                    const widthVal = parseFloat(allStyles[status]?.[widthKey]) || 0;
                    const colorVal = allStyles[status]?.[colorKey] ?? '#000000';
                    inputHtml = `<div class="form-field-compound">
                                    <input type="number" class="config-input" data-status="${status}" data-key="${widthKey}" value="${widthVal}" min="0" max="20" step="1" data-unit="${unit}" style="max-width: 70px;">
                                    <span style="width: 30px; text-align: left; margin-left: 5px;">${unit}</span>
                                    <input type="color" data-status="${status}" data-key="${colorKey}" value="${colorVal}">
                                    <input type="text" class="config-input color-text-input" data-status="${status}" data-key="${colorKey}" value="${colorVal}">
                                    </div>`;
                    break;
                    const mainDiv = document.createElement('div');
                    mainDiv.className = 'form-field-compound';
                    const widthInput = Object.assign(document.createElement('input'), { type: 'number', className: 'config-input', value: widthVal, min: 0, max: 20, step: 1, dataset: { status, key: widthKey, unit }});
                    widthInput.style.maxWidth = '70px';
                    const widthSpan = Object.assign(document.createElement('span'), { textContent: unit });
                    widthSpan.style.cssText = 'width: 30px; text-align: left; margin-left: 5px;';
                    const colorInput = Object.assign(document.createElement('input'), { type: 'color', value: colorVal, dataset: { status, key: colorKey } });
                    const textInput = Object.assign(document.createElement('input'), { type: 'text', className: 'config-input color-text-input', value: colorVal, dataset: { status, key: colorKey } });
                    colorInput.addEventListener('change', (e) => { textInput.value = e.target.value; textInput.dispatchEvent(new Event('input', { bubbles: true })); });
                    textInput.addEventListener('input', (e) => { let potentialColor = e.target.value; if (/^[0-9A-F]{6}$/i.test(potentialColor) || /^[0-9A-F]{3}$/i.test(potentialColor)) { potentialColor = '#' + potentialColor; e.target.value = potentialColor; } colorInput.value = potentialColor; });
                    mainDiv.append(widthInput, widthSpan, colorInput, textInput);
                    fieldContainer.appendChild(mainDiv);
                    parentContainer.appendChild(fieldContainer);
                    return;
                }
                default: // text, color, etc.
                    inputHtml = `<input type="${schema.type}" class="config-input" data-status="${status}" data-key="${prop}" value="${value}">`;
                    break;
            }
            fieldContainer.innerHTML += inputHtml;
            parentContainer.appendChild(fieldContainer);
        }

        function handleGlobalStyleInputChange(event) {
            const input = event.target;
            const key = input.dataset.key;
            if (!key) return;

            // File inputs are handled by a separate 'change' listener that calls handleImageUpload.
            // This prevents the 'fakepath' from being saved to the database.
            if (input.type === 'file') return;

            const status = input.dataset.status; // NEW: Check for status
            let newValue;

            if (input.type === 'checkbox') {
                newValue = input.checked;
            } else {
                newValue = input.value;
                if (input.dataset.unit) { // Check for the unit from numberWithUnit
                    newValue += input.dataset.unit;
                }
            }

            // NEW: Update image preview when URL is typed manually
            if (input.type === 'text' && (key === 'boardImageUrl' || key === 'stampImageUrl')) {
                const fieldContainer = input.closest('.form-field');
                if (fieldContainer) {
                    const previewImg = fieldContainer.querySelector('.image-upload-preview');
                    if (previewImg) {
                        previewImg.src = input.value;
                        previewImg.style.display = input.value ? 'block' : 'none';
                    }
                }
            }

            if (status) { // This is a style property
                const oldValue = allStyles[status]?.[key] ?? '';
                if (!allStyles[status]) allStyles[status] = {};
                allStyles[status][key] = newValue; // Optimistic update
                debouncedSaveStyle(status, { [key]: newValue }, input, oldValue);
            } else { // This is a config property
                const oldValue = config[key] ?? '';
                config[key] = newValue; // Optimistic update
                if (key === 'boardImageUrl') {
                    loadBoardImage(newValue);
                }
                debouncedSaveConfig({ [key]: newValue }, input, oldValue);
            }
            renderTiles(); // Optimistically re-render
        }

        // --- Style Preview Logic ---
        function createStylePreviewButtons() {
            const container = document.getElementById('style-preview-controls');
            const statuses = [...STATUSES, null];
            statuses.forEach(status => {
                const btn = document.createElement('button');
                btn.textContent = status || 'Clear Preview';
                btn.onclick = () => {
                    currentPreviewStatus = status;
                    container.querySelectorAll('button').forEach(b => b.style.backgroundColor = '');
                    if (status) btn.style.backgroundColor = '#0088cc';
                    renderTiles();
                };
                container.appendChild(btn);
            });
        }

        // --- Prerequisite Line Rendering ---
        function parsePrerequisites(prereqString) {
            if (!prereqString || !prereqString.trim()) {
                return [];
            }
            const trimmed = prereqString.trim();
            if (trimmed.startsWith('[')) { // New format [[A,B],[C]]
                try {
                    const parsed = JSON.parse(trimmed);
                    if (Array.isArray(parsed) && (parsed.length === 0 || Array.isArray(parsed[0]))) {
                        return parsed;
                    }
                } catch (e) { /* fall through to old format */ }
            }
            // Old format "A,B,C" treated as [[A,B,C]]
            return [trimmed.split(',').map(s => s.trim()).filter(Boolean)];
        }

        function renderPrereqLines() {
            prereqLinesSvg.innerHTML = ''; // Clear previous lines

            if (prereqVisMode === 'hide' || lastSelectedTileIndex === null) {
                return;
            }

            const destTileData = tilesData[lastSelectedTileIndex];
            if (!destTileData) return;

            const orGroups = parsePrerequisites(destTileData['Prerequisites']);
            if (orGroups.length === 0) return;

            const destCenter = {
                x: parseFloat(destTileData['Left (%)']) + parseFloat(destTileData['Width (%)']) / 2,
                y: parseFloat(destTileData['Top (%)']) + parseFloat(destTileData['Height (%)']) / 2
            };

            const totalGroups = orGroups.length;
            const baseStrokeWidth = 0.3; // The width of the top-most line
            const strokeWidthIncrement = 0.4; // The extra width for each layer underneath
            const outlinePadding = 0.15; // Extra width for the black outline

            // Draw layer by layer, from thickest (bottom) to thinnest (top).
            // This ensures thinner lines are rendered on top of thicker ones.
            orGroups.forEach((andGroup, orIndex) => {
                // The thickest layer is drawn first. Its index is 0.
                const strokeWidth = baseStrokeWidth + (totalGroups - 1 - orIndex) * strokeWidthIncrement;
                const outlineWidth = strokeWidth + outlinePadding;
                
                // Distribute hue evenly across the color wheel for maximum distinction.
                const hue = (orIndex * 360) / totalGroups;
                const color = `hsl(${hue}, 85%, 55%)`;

                const outlinesFragment = document.createDocumentFragment();
                const fillsFragment = document.createDocumentFragment();

                andGroup.forEach(tileId => {
                    const sourceTileData = tilesData.find(t => t.id === tileId);
                    if (!sourceTileData) return;

                    const sourceCenter = {
                        x: parseFloat(sourceTileData['Left (%)']) + parseFloat(sourceTileData['Width (%)']) / 2,
                        y: parseFloat(sourceTileData['Top (%)']) + parseFloat(sourceTileData['Height (%)']) / 2
                    };

                    const p1 = { ...sourceCenter };
                    const p2 = { ...destCenter };

                    // Create outline line for this segment and add to fragment
                    const outlineLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    outlineLine.setAttribute('x1', `${p1.x}%`); outlineLine.setAttribute('y1', `${p1.y}%`);
                    outlineLine.setAttribute('x2', `${p2.x}%`); outlineLine.setAttribute('y2', `${p2.y}%`);
                    outlineLine.setAttribute('stroke', 'black');
                    outlineLine.setAttribute('stroke-width', `${outlineWidth}%`);
                    outlineLine.setAttribute('stroke-linecap', 'round');
                    outlinesFragment.appendChild(outlineLine);

                    // Create fill line for this segment and add to a separate fragment
                    const fillLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    fillLine.setAttribute('x1', `${p1.x}%`); fillLine.setAttribute('y1', `${p1.y}%`);
                    fillLine.setAttribute('x2', `${p2.x}%`); fillLine.setAttribute('y2', `${p2.y}%`);
                    fillLine.setAttribute('stroke', color);
                    fillLine.setAttribute('stroke-width', `${strokeWidth}%`);
                    fillLine.setAttribute('stroke-linecap', 'round');
                    fillsFragment.appendChild(fillLine);
                });

                // For each layer, append all its outlines first, then all its fills.
                // This ensures fills are drawn on top of outlines within the same layer.
                prereqLinesSvg.appendChild(outlinesFragment);
                prereqLinesSvg.appendChild(fillsFragment);
            });
        }

        // --- New Data Sync and Security Logic ---

        async function handleImageUpload(input) {
            const file = input.files[0];
            if (!file) return;
            const key = input.dataset.key;
            const status = input.dataset.status; // NEW
            const storagePath = input.dataset.path;

            // Find the corresponding text input and preview image
            const compoundDiv = input.closest('.form-field-compound');
            const textInput = compoundDiv.querySelector('input[type="text"]');
            const fieldContainer = input.closest('.form-field');
            const previewImg = fieldContainer.querySelector('.image-upload-preview');
            
            showGlobalLoader();

            // If there's an old image URL, delete the old file from storage
            const oldUrl = textInput.value; // Get URL from the text input
            if (oldUrl && oldUrl.includes('firebasestorage')) {
                try {
                    const oldRef = fb.ref(storage, oldUrl);
                    await fb.deleteObject(oldRef);
                } catch (error) {
                    if (error.code !== 'storage/object-not-found') console.error("Could not delete old file:", error);
                }
            }

            try {
                const newFileRef = fb.ref(storage, `${storagePath}/${file.name}`);
                await fb.uploadBytes(newFileRef, file);
                const url = await fb.getDownloadURL(newFileRef);

                // Update the text input with the new URL
                textInput.value = url;
                
                // Manually trigger an input event on the text field to save the new URL
                textInput.dispatchEvent(new Event('input', { bubbles: true }));

                previewImg.src = url;
                previewImg.style.display = 'block';
                showMessage(`Uploaded ${file.name}`, false);
            } catch (error) {
                showMessage(`Upload failed: ${error.message}`, true);
            } finally {
                hideGlobalLoader();
            }
        }

        async function handleOverrideImageUpload(fileInput, textInput) {
            const file = fileInput.files[0];
            if (!file) return;
            const storagePath = fileInput.dataset.path;

            showGlobalLoader();

            const oldUrl = textInput.value;
            if (oldUrl && oldUrl.includes('firebasestorage')) {
                try {
                    const oldRef = fb.ref(storage, oldUrl);
                    await fb.deleteObject(oldRef);
                } catch (error) {
                    if (error.code !== 'storage/object-not-found') console.error("Could not delete old file:", error);
                }
            }

            try {
                const newFileRef = fb.ref(storage, `${storagePath}/${file.name}`);
                await fb.uploadBytes(newFileRef, file);
                const url = await fb.getDownloadURL(newFileRef);

                textInput.value = url;
                textInput.dispatchEvent(new Event('input', { bubbles: true }));

                showMessage(`Uploaded ${file.name}`, false);
            } catch (error) {
                showMessage(`Upload failed: ${error.message}`, true);
            } finally {
                hideGlobalLoader();
            }
        }

        function initializeApp() {
            console.log("Setting up real-time data listeners...");
            showGlobalLoader();

            // Detach old listeners if they exist, to prevent memory leaks on re-initialization
            if (unsubscribeConfig) unsubscribeConfig();
            if (unsubscribeTiles) unsubscribeTiles();
            if (unsubscribeUsers) unsubscribeUsers();
            if (unsubscribeTeams) unsubscribeTeams();
            if (unsubscribeStyles) unsubscribeStyles();

            let initialDataLoaded = { config: false, tiles: false, users: false, teams: false, styles: false };
            const checkAllLoaded = () => {
                if (Object.values(initialDataLoaded).every(Boolean)) {
                    hideGlobalLoader();
                    showMessage('Live editor initialized and synced!', false);
                }
            };

            // Listener for the main configuration document (excluding teams)
            unsubscribeConfig = fb.onSnapshot(fb.doc(db, 'config', 'main'), (doc) => {
                console.log("Config updated in real-time.");
                config = doc.exists() ? doc.data() : {};
                renderGlobalConfig();
                loadBoardImage(config.boardImageUrl || '');
                renderTiles(); // Re-render tiles as global styles may have changed

                if (!initialDataLoaded.config) {
                    initialDataLoaded.config = true;
                    checkAllLoaded();
                }
            }, (error) => {
                showMessage('Error loading config: ' + error.message, true);
                hideGlobalLoader();
            });

            // Listener for the tiles collection
            unsubscribeTiles = fb.onSnapshot(fb.collection(db, 'tiles'), (snapshot) => {
                console.log("Tiles updated in real-time.");
                let needsRender = false;
                let selectedTileUpdated = false;

                snapshot.docChanges().forEach(change => {
                    needsRender = true;
                    const changedDoc = { ...change.doc.data(), docId: change.doc.id }; // Add the docId to the object
                    const index = tilesData.findIndex(t => t.docId === changedDoc.docId);

                    if (change.type === "added") {
                        if (index === -1) tilesData.push(changedDoc);
                    }
                    if (change.type === "modified") {
                        if (index > -1) {
                            tilesData[index] = changedDoc;
                            if (lastSelectedTileIndex === index) {
                                selectedTileUpdated = true;
                            }
                        }
                    }
                    if (change.type === "removed") {
                        if (index > -1) {
                            tilesData.splice(index, 1);
                            if (lastSelectedTileIndex === index) {
                                lastSelectedTileIndex = null;
                                selectedTileUpdated = true; // Will clear the editor
                            } else if (lastSelectedTileIndex > index) {
                                lastSelectedTileIndex--; // Adjust index
                            }
                        }
                    }
                });

                // After all changes are processed, update the selector
                populateTileSelector();

                if (needsRender) {
                    renderTiles();
                    if (selectedTileUpdated) {
                        updateEditorPanel(lastSelectedTileIndex);
                    }
                }

                if (!initialDataLoaded.tiles) {
                    initialDataLoaded.tiles = true;
                    checkAllLoaded();
                }
            }, (error) => {
                showMessage('Error loading tiles: ' + error.message, true);
                hideGlobalLoader();
            });

            // Listener for the users collection
            unsubscribeUsers = fb.onSnapshot(fb.collection(db, 'users'), (snapshot) => {
                console.log("Users updated in real-time.");
                allUsers = snapshot.docs.map(doc => ({ ...doc.data(), uid: doc.id }));
                // Only re-render the teams list if it has already been populated.
                // This prevents a race condition where an empty list is rendered
                // if user data arrives before team data.
                if (initialDataLoaded.teams) renderTeamsList();
                if (!initialDataLoaded.users) {
                    initialDataLoaded.users = true;
                    checkAllLoaded();
                }
            }, (error) => {
                showMessage('Error loading users: ' + error.message, true);
                hideGlobalLoader();
            });

            // Listener for the new teams collection
            const teamsQuery = fb.query(fb.collection(db, 'teams'), fb.orderBy(fb.documentId()));
            unsubscribeTeams = fb.onSnapshot(teamsQuery, (snapshot) => {
                console.log("Teams updated in real-time.");

                // Rebuild the teams object, consistent with other pages (admin, overview).
                allTeams = {};
                snapshot.docs.forEach(doc => {
                    allTeams[doc.id] = doc.data();
                });
                renderTeamsList();

                if (!initialDataLoaded.teams) {
                    initialDataLoaded.teams = true;
                    checkAllLoaded();
                }
            }, (error) => { showMessage('Error loading teams: ' + error.message, true); hideGlobalLoader(); });

            // Listener for the new styles collection
            unsubscribeStyles = fb.onSnapshot(fb.collection(db, 'styles'), (snapshot) => {
                console.log("Styles updated in real-time.");
                allStyles = {};
                snapshot.docs.forEach(doc => {
                    allStyles[doc.id] = doc.data();
                });
                renderGlobalConfig(); // Re-render config form which now includes styles
                renderTiles(); // Re-render tiles as styles may have changed

                if (!initialDataLoaded.styles) {
                    initialDataLoaded.styles = true;
                    checkAllLoaded();
                }
            }, (error) => {
                showMessage('Error loading styles: ' + error.message, true);
            });

            // Initial UI setup that doesn't depend on data
            createEditorForm();
            updateEditorPanel(null);
        }

        function loadBoardImage(imageUrl) {
            // Clear previous error messages if any
            const existingError = boardContent.querySelector('.error-message');
            if (existingError) existingError.remove();

            if (!imageUrl) {
                boardImage.src = '';
                boardContent.style.backgroundImage = 'none';
                // Add a placeholder aspect ratio if no image
                boardContent.style.aspectRatio = '1 / 1';
                return;
            }

            // Use the existing hidden img tag to load and get aspect ratio
            boardImage.onload = () => {
                boardContent.style.aspectRatio = `${boardImage.naturalWidth} / ${boardImage.naturalHeight}`;
                boardContent.style.backgroundImage = `url('${imageUrl}')`;
            };
            boardImage.onerror = () => {
                boardContent.style.backgroundImage = 'none';
                boardContent.style.aspectRatio = '1 / 1';
                boardContent.appendChild(Object.assign(document.createElement('div'), { className: 'error-message', innerHTML: `<strong>Board Image Failed to Load</strong><br><small>Check the URL in the config or try re-uploading.</small>` }));
            };
            boardImage.src = imageUrl;
        }

        function renderTeamsList() {
            const teamsContainer = document.getElementById('teams-container');

            // Preserve focus and value of the active input.
            let activeElement = document.activeElement;
            let activeTeamId = null;
            let activeFieldClass = null;
            let activeValue = null;
            let selectionStart = null;
            let selectionEnd = null;

            if (activeElement && teamsContainer.contains(activeElement)) {
                const teamItem = activeElement.closest('.team-item');
                if (teamItem && teamItem.dataset.teamId) {
                    activeTeamId = teamItem.dataset.teamId;
                    activeValue = activeElement.value;
                    selectionStart = activeElement.selectionStart;
                    selectionEnd = activeElement.selectionEnd;
                    // Determine which field it is by class
                    if (activeElement.classList.contains('team-name')) {
                        activeFieldClass = 'team-name';
                    } else if (activeElement.classList.contains('team-captain')) {
                        activeFieldClass = 'team-captain';
                    }
                }
            }

            teamsContainer.innerHTML = ''; // Now clear the container
            if (!allTeams || Object.keys(allTeams).length === 0) return;

            // Sort by ID to maintain consistent order, as iterating object keys is not guaranteed.
            const sortedTeamIds = Object.keys(allTeams).sort();
            sortedTeamIds.forEach(teamId => {
                const team = allTeams[teamId];
                addTeamRow(teamId, team.name || '', team.captainId || '');
            });

            // Restore focus and value.
            if (activeTeamId && activeFieldClass) {
                const newTeamItem = teamsContainer.querySelector(`.team-item[data-team-id="${activeTeamId}"]`);
                if (newTeamItem) {
                    const newActiveElement = newTeamItem.querySelector(`.${activeFieldClass}`);
                    if (newActiveElement) {
                        newActiveElement.value = activeValue;
                        newActiveElement.focus();
                        try {
                            newActiveElement.setSelectionRange(selectionStart, selectionEnd);
                        } catch (e) { /* no-op for select */ }
                    }
                }
            }
        }

        function addTeamRow(teamId, name = '', captainId = '') {
            const container = document.getElementById('teams-container');
            const item = document.createElement('div');
            item.className = 'team-item';
            item.dataset.teamId = teamId;

            const idDisplay = document.createElement('span');
            idDisplay.className = 'team-id-display';
            idDisplay.textContent = teamId;
            idDisplay.title = 'Team ID (fixed)';

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'team-field team-name';
            nameInput.placeholder = 'Team Name';
            nameInput.value = name;

            const captainSelect = document.createElement('select');
            captainSelect.className = 'team-field team-captain';
            captainSelect.innerHTML = `<option value="">-- No Captain --</option>`;
            allUsers.forEach(user => {
                captainSelect.innerHTML += `<option value="${user.uid}" ${user.uid === captainId ? 'selected' : ''}>${user.displayName || user.email}</option>`;
            });

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'remove-team-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.style.marginTop = 0; // Override default button margin
            
            item.append(idDisplay, nameInput, captainSelect, removeBtn); container.appendChild(item);

            // Add listeners after appending
            nameInput.oninput = (e) => debouncedUpdateTeam(teamId, 'name', e.target.value);
            captainSelect.onchange = (e) => debouncedUpdateTeam(teamId, 'captainId', e.target.value || null);
            removeBtn.onclick = () => {
                if (confirm(`Are you sure you want to delete team "${name || teamId}"?`)) {
                    deleteTeam(teamId);
                }
            };
        }

        document.getElementById('add-team-btn').addEventListener('click', () => {
            // Find the highest existing team number to create the next one.
            // We do not reuse IDs from deleted teams to maintain data integrity,
            // as old submissions may still reference the old ID.
            if (!allTeams) allTeams = {};
            const existingNumbers = Object.keys(allTeams).map(id => parseInt(id.replace('team', ''), 10)).filter(n => !isNaN(n));
            const maxNumber = existingNumbers.length > 0 ? Math.max(...existingNumbers) : 0;
            const newId = `team${String(maxNumber + 1).padStart(2, '0')}`;

            fb.setDoc(fb.doc(db, 'teams', newId), { name: 'New Team', captainId: null })
                .then(() => showMessage(`Team ${newId} created.`, false))
                .catch(err => showMessage(`Error creating team: ${err.message}`, true));
            // The onSnapshot listener will automatically add the new row to the UI.
        });

        // --- NEW: Auto-saving logic ---
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) { 
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        const debouncedSaveTile = debounce(async (docId, data, inputElement, oldValue) => {
            if (!docId) return;
            const tileRef = fb.doc(db, 'tiles', docId);
            const key = Object.keys(data)[0];
            const tileIndex = tilesData.findIndex(t => t.docId === docId);

            return fb.updateDoc(tileRef, data).then(() => {
                console.log(`Tile ${docId} auto-saved.`);
            }).catch(err => {
                showMessage(`Error saving tile: ${err.message}`, true);
                // Revert the data and UI on failure
                if (tileIndex !== -1) {
                    console.warn(`Reverting tile field '${key}' to '${oldValue}' due to save error.`);
                    // 1. Revert the data model
                    tilesData[tileIndex][key] = oldValue;

                    // 2. Revert the input UI
                    const syncName = inputElement.dataset.sync;
                    if (syncName) {
                        detailsForm.querySelectorAll(`[data-sync="${syncName}"]`).forEach(el => {
                            if (syncName === 'Rotation' && el.type === 'range') {
                                el.value = parseFloat(oldValue) || 0;
                            } else {
                                el.value = oldValue;
                            }
                        });
                    } else {
                        inputElement.value = oldValue;
                    }

                    // 3. Re-render all tiles to revert visual state (e.g., position, size)
                    renderTiles();
                }
            });
        }, 1000);

        const debouncedSaveConfig = debounce((data, inputElement, oldValue) => {
            const configRef = fb.doc(db, 'config', 'main');
            const key = Object.keys(data)[0];

            // Use setDoc with merge: true. This will create the document if it doesn't exist,
            // and update it if it does, which is perfect for initial setup.
            fb.setDoc(configRef, data, { merge: true }).then(() => {
                console.log('Config auto-saved.');
            }).catch(err => {
                showMessage(`Error saving config: ${err.message}`, true);
                if (inputElement) {
                    console.warn(`Reverting config field '${key}' to '${oldValue}' due to save error.`);
                    config[key] = oldValue; // Revert data model
                    if (inputElement.type === 'checkbox') {
                        inputElement.checked = String(oldValue).toUpperCase() === 'TRUE';
                    } else {
                        inputElement.value = oldValue;
                    }
                    if (inputElement.type === 'range' && inputElement.nextElementSibling) {
                        inputElement.nextElementSibling.textContent = oldValue;
                    }
                    renderTiles(); // Re-render to show reverted state
                }
            });
        }, 1000);

        const debouncedUpdateTeam = debounce((teamId, field, value) => {
            const teamRef = fb.doc(db, 'teams', teamId);
            fb.updateDoc(teamRef, { [field]: value })
                .then(() => console.log(`Team ${teamId} field '${field}' auto-saved.`))
                .catch(err => {
                    showMessage(`Error saving team ${teamId}: ${err.message}`, true);
                    renderTeamsList(); // Re-render to revert UI change
                });
        }, 1500);

        const debouncedSaveStyle = debounce((styleId, data, inputElement, oldValue) => {
            const styleRef = fb.doc(db, 'styles', styleId);
            const key = Object.keys(data)[0];

            fb.setDoc(styleRef, data, { merge: true }).then(() => {
                console.log(`Style ${styleId} auto-saved.`);
            }).catch(err => {
                showMessage(`Error saving style: ${err.message}`, true);
                if (inputElement) {
                    console.warn(`Reverting style field '${key}' for ${styleId} to '${oldValue}' due to save error.`);
                    allStyles[styleId][key] = oldValue; // Revert data model
                    // Re-render the whole config section to revert the UI
                    renderGlobalConfig();
                }
            });
        }, 1000);

        function deleteTeam(teamId) {
            fb.deleteDoc(fb.doc(db, 'teams', teamId))
                .catch(err => showMessage(`Error deleting team: ${err.message}`, true));
        }

        // --- NEW: Global Loader & Message Box Functions ---
        function showGlobalLoader() {
            document.getElementById('global-loader').style.display = 'block';
        }
        function hideGlobalLoader() {
            document.getElementById('global-loader').style.display = 'none';
        }
        function showMessage(text, isError = false) {
            const box = document.getElementById('message-box');
            box.textContent = text;
            box.style.backgroundColor = isError ? '#c0392b' : '#27ae60';
            box.classList.add('show');
            setTimeout(() => box.classList.remove('show'), 4000);
        }


    </script>
</body>
</html>