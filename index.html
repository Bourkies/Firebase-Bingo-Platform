<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Firebase Bingo Platform</title>
  <style>
    :root {
      --board-bg: #1a1a1a; --text-light: #f0f0f0; --text-dark: #222;
      --accent-color: #00b8d4; --modal-bg: rgba(20, 20, 20, 0.95);
      --input-bg: #333; --border-color: #444; --error-bg: #4d2a2a;
      --error-border: #c0392b; --font-main: 'Roboto', 'Helvetica Neue', 'Arial', sans-serif;
    }
    body {
      font-family: var(--font-main); background-color: var(--board-bg); color: var(--text-light);
      margin: 0; padding: 1rem; display: flex; flex-direction: column;
      align-items: center; min-height: 100vh; box-sizing: border-box;
    } .navbar {
      width: 100%;
      background-color: var(--input-bg);
      border-radius: 8px;      
      padding: 0.5rem 1rem;
      margin-bottom: 1.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-sizing: border-box;
    }
    .nav-links a, .nav-actions button {      
      color: var(--text-light); text-decoration: none;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      transition: background-color 0.2s; background: none;
      border: none;
      font-size: 1rem;
      cursor: pointer;
    }
    #auth-container .nav-button { /* NEW: Specific class for buttons in auth container */
        padding: 0.5rem 1rem; border-radius: 6px; background: none; border: none;
        color: var(--text-light); font-size: 1rem; cursor: pointer;
    }
    .nav-links a:hover, .nav-actions button:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }
    .nav-links a.active {
      background-color: var(--accent-color);
      color: var(--text-dark);
      font-weight: bold;
    }
    #auth-container { display: flex; align-items: center; gap: 1rem; }
    #user-info { font-size: 0.9rem; color: #a0a0a0; }
    .global-loader {
        position: fixed; top: 0; left: 0;
        width: 100%;
        height: 3px;
        background: linear-gradient(to right, var(--accent-color) 20%, #00d9f5 50%, var(--accent-color) 80%);
        background-size: 200% auto;
        animation: loading-animation 1.5s linear infinite;
        z-index: 9999;
        display: block;
    }
    @keyframes loading-animation { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
    .controls { width: 100%; margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
    h1 { margin: 0; font-size: 1.5rem; font-weight: 500; }
    #team-selector { padding: 0.5rem 1rem; font-size: 1rem; background-color: var(--input-bg); color: var(--text-light); border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer; }
    #board-container {
      position: relative; width: 100%;
      background-size: cover; background-position: center;
      border-radius: 12px; box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5); overflow: hidden;
      display: flex; justify-content: center; align-items: center;
      /* IMPROVEMENT: Placeholder background */
      background-color: #222;
      background-image: linear-gradient(45deg, #2a2a2a 25%, transparent 25%), linear-gradient(-45deg, #2a2a2a 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #2a2a2a 75%), linear-gradient(-45deg, transparent 75%, #2a2a2a 75%);
      /* The size for the placeholder gradient is now handled in JS to avoid conflicts */
    }
    @keyframes pulse-border {
      0% { box-shadow: 0 0 0 0 rgba(229, 115, 115, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(229, 115, 115, 0); }
      100% { box-shadow: 0 0 0 0 rgba(229, 115, 115, 0); }
    }
    .tile-overlay {
      position: absolute; box-sizing: border-box;
      transition: background-color 0.3s ease, border-color 0.3s ease, transform 0.3s ease;
      display: flex; align-items: center; justify-content: center; text-align: center;
      color: white; font-weight: bold; text-shadow: 1px 1px 3px black;
      font-size: 0.9rem; padding: 4px; cursor: pointer;
    }
    .tile-overlay.requires-action {
      animation: pulse-border 2s infinite; /* Enable animation only for these tiles */
    }
    .stamp-image {
      position: absolute; width: 100%; height: 100%; background-size: contain;
      background-repeat: no-repeat; pointer-events: none; background-position: center;
    }
    .info-container {
      display: flex; flex-direction: column; gap: 1.5rem; margin-top: 1.5rem; width: 100%;
    }
    #color-key-container {
      display: flex; flex-wrap: wrap; justify-content: center; gap: 1rem;
      padding: 1rem; background-color: var(--input-bg); border-radius: 8px;
    }
    .key-item { display: flex; align-items: center; gap: 0.5rem; }
    .key-color-box {
      width: 20px; height: 20px; border-radius: 4px; border: 1px solid var(--border-color);
      /* For stamp images */
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
    }
    #scoreboard-container {
      display: none; flex-direction: column; gap: 0.5rem; padding: 1rem;
      background-color: var(--input-bg); border-radius: 8px;
    }
    #scoreboard-container h2 { margin: 0 0 0.5rem 0; text-align: center; font-weight: 500; }
    .scoreboard-item { display: grid; grid-template-columns: 30px 1fr 60px; align-items: center; padding: 0.5rem; border-radius: 6px; }
    .scoreboard-item:nth-child(odd) { background-color: rgba(0,0,0,0.2); }
    .scoreboard-rank, .scoreboard-score { font-weight: bold; }
    .scoreboard-score { text-align: right; }
    #submission-modal, #welcome-modal {
      display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; /* Login modal shares some styles */
      background-color: var(--modal-bg); backdrop-filter: blur(5px); justify-content: center; align-items: center;
      padding: 1rem; box-sizing: border-box;
    }
    .modal-content {
      background-color: #2a2a2a; padding: 2rem; border-radius: 12px; width: 100%;
      max-width: 500px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); position: relative;
      max-height: 95vh; overflow-y: auto;
    }
    .close-button {
      position: absolute; top: 1rem; right: 1rem; font-size: 1.5rem;
      font-weight: bold; color: #aaa; cursor: pointer; line-height: 1;
    }
    .close-button:hover { color: white; }
    #submission-form h2 { margin-top: 0; }
    #submission-form h3 { margin: 0.5rem 0 1rem 0; color: var(--accent-color); }
    #submission-form p { color: #ccc; }
    #submission-form label { display: block; margin-top: 1rem; }
    #submission-form input, #submission-form textarea {
      width: 100%; padding: 0.75rem; margin-top: 0.5rem; background-color: var(--input-bg);
      border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-light); box-sizing: border-box;
    }
    #submission-form .checkbox-container { display: flex; align-items: center; margin-top: 1.5rem; gap: 0.5rem; }
    #submission-form input[type="checkbox"] { width: auto; margin: 0; }
    #submission-form button {
      width: 100%; padding: 0.75rem; margin-top: 1.5rem; background-color: var(--accent-color);
      color: var(--text-dark); font-weight: bold; font-size: 1rem; border: none;
      border-radius: 8px; cursor: pointer; transition: background-color 0.2s;
    }
    #submission-form button:hover { background-color: #00d9f5; }
    /* NEW: Resubmit button style */
    #submission-form button.resubmit-btn {
        background-color: var(--error-border);
        color: var(--text-light);
    }
    #submission-form button.resubmit-btn:hover {
        background-color: #e74c3c;
    }
    #submission-form button:disabled { background-color: #555; cursor: not-allowed; }
    /* --- NEW: Evidence Input Styling --- */
    #player-name-container {
        background-color: var(--input-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }
    #team-members-checkboxes {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem 1rem; /* row-gap column-gap */
        max-height: 150px;
        overflow-y: auto;
    }
    .player-checkbox-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        white-space: nowrap;
    }
    .player-name-option {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    #manual-player-name {
        margin-top: 0.25rem;
    }
    #evidence-container { display: flex; flex-direction: column; gap: 1rem; margin-top: 0.5rem; }
    .evidence-item {
        background-color: var(--input-bg); padding: 1rem; border-radius: 8px;
        border: 1px solid var(--border-color); display: flex; flex-direction: column; gap: 0.75rem;
    }
    .evidence-item-header { display: flex; justify-content: space-between; align-items: center; }
    .evidence-item-header label { margin: 0; font-weight: bold; }
    .remove-evidence-btn {
        background: none; border: none; color: #aaa; font-size: 1.2rem;
        cursor: pointer; padding: 0 0.5rem; line-height: 1;
    }
    .remove-evidence-btn:hover { color: var(--error-border); }
    #add-evidence-btn {
        width: auto; padding: 0.5rem 1rem; margin-top: 1rem; background-color: transparent;
        color: var(--accent-color); border: 1px dashed var(--accent-color);
        font-weight: normal; font-size: 0.9rem;
    }
    #add-evidence-btn:hover { background-color: rgba(0, 184, 212, 0.1); }
    /* NEW: Admin Feedback Display */
    #admin-feedback-display {
        display: none; /* Hidden by default */
        background-color: var(--error-bg);
        border: 1px solid var(--error-border);
        border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem;
    }
    #admin-feedback-display h4 { margin: 0 0 0.5rem 0; color: #ffc107; }
    .error-message {
        padding: 2rem; background-color: var(--error-bg); border: 2px dashed var(--error-border);
        border-radius: 8px; text-align: center; width: 80%; word-wrap: break-word; position: absolute; z-index: 1;
    }
    #message-box {
      position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
      background-color: #333; color: white; padding: 1rem 2rem; border-radius: 8px;
      z-index: 2000; opacity: 0; transition: opacity 0.5s; pointer-events: none;
    }
    #message-box.show { opacity: 1; }
    /* --- NEW: Tooltip Style --- */
    #tile-tooltip {
      display: none;
      position: fixed;
      z-index: 1001;
      background-color: #111;
      color: #fff;
      padding: 0.75rem;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      max-width: 300px;
      pointer-events: none;
      font-size: 0.9rem;
      line-height: 1.4;
    }
    #tile-tooltip h4 {
        margin: 0 0 0.5rem 0;
        color: var(--accent-color);
        font-size: 1rem;
    }
    #tile-tooltip p {
        margin: 0;
        color: #ccc;
    }
    /* --- NEW: Welcome Modal Styles --- */
    #welcome-modal .modal-content p {
        white-space: pre-wrap;
        text-align: left;
        margin: 1rem 0 1.5rem 0;
        color: #ccc;
    }
    #welcome-modal .modal-content h2 {
        margin-top: 0;
        color: var(--accent-color);
    }
    #welcome-form label {
        display: block;
        margin-bottom: 0.5rem;
    }
    #welcome-form input {
        width: 100%; padding: 0.75rem; background-color: var(--input-bg);
        border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-light); box-sizing: border-box;
    }
    #welcome-form button {
        width: 100%; padding: 0.75rem; margin-top: 1.5rem; background-color: var(--accent-color);
        color: var(--text-dark); font-weight: bold; font-size: 1rem; border: none;
        border-radius: 8px; cursor: pointer; transition: background-color 0.2s;
    }
    #welcome-form button:hover {
        background-color: #00d9f5;
    }
    /* --- NEW: Login Modal Styles --- */
    #login-modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: var(--modal-bg); backdrop-filter: blur(5px); justify-content: center; align-items: center; }
    #login-modal .modal-content { max-width: 400px; text-align: center; }
    #login-modal h2 { margin-top: 0; color: var(--accent-color); }
    .login-options { display: flex; flex-direction: column; gap: 1rem; margin-top: 1.5rem; }
    .login-options button {
        width: 100%; padding: 0.75rem; font-size: 1rem; border-radius: 8px;
        cursor: pointer; transition: background-color 0.2s; display: flex;
        align-items: center; justify-content: center; gap: 0.75rem;
    }
    #login-google { background-color: #4285F4; color: white; border: none; }
    #login-google:hover { background-color: #5a95f5; }
    #login-anon { background-color: #607d8b; color: white; border: none; }
    #login-anon:hover { background-color: #78909c; }
    .login-options svg { width: 20px; height: 20px; }
    .anon-warning {
        margin-top: 1.5rem; padding: 0.75rem; background-color: rgba(255, 193, 7, 0.1);
        border: 1px solid rgba(255, 193, 7, 0.3); border-radius: 8px; font-size: 0.85rem;
        text-align: left; color: #ffecb3;
    }
    .anon-warning strong { color: #ffc107; }
    .anon-warning ul { padding-left: 1.25rem; margin: 0.5rem 0 0 0; }
  </style>
</head>
<body>
  <div id="global-loader" class="global-loader"></div>

  <div class="navbar">
    <div class="nav-links">
      <a href="./index.html" class="active">Player View</a>
      <a href="./overview.html" id="overview-nav-link" style="display: none;">Overview</a>
      <a href="./admin.html" id="admin-nav-link" style="display: none;">Admin</a>
      <a href="./setup.html" id="setup-nav-link" style="display: none;">Setup</a>
    </div>
    <div id="auth-container" class="nav-actions">
        <span id="user-info"></span>
        <button id="change-name-btn" class="nav-button" style="display: none;">Change Name</button>
        <button id="auth-button">Login</button>
    </div>
  </div>

  <div class="controls">
    <h1 id="page-title">OSRS Bingo</h1>
    <select id="team-selector" onchange="handleTeamChange()"></select>
  </div>

  <div id="board-container">
    <!-- Tiles will be rendered here -->
  </div>
  <div class="info-container">
    <div id="color-key-container"></div>
    <div id="scoreboard-container"></div>
  </div>
  <div id="submission-modal">
    <div class="modal-content">
      <span class="close-button" onclick="closeModal()">&times;</span>
      <form id="submission-form" onsubmit="handleFormSubmit(event)">
        <!-- UPDATED: Tile ID and Name format -->
        <h2 id="modal-tile-name"></h2>
        <h3 id="modal-team-name"></h3>
        <p id="modal-tile-desc"></p>
        <div id="admin-feedback-display">
            <h4>Admin Feedback</h4>
            <p id="admin-feedback-text"></p>
        </div>
        <input type="hidden" id="modal-tile-id">
        <label for="player-name-container">Player Name(s):</label>
        <div id="player-name-container">
            <div id="team-members-checkboxes"></div>
            <div class="player-name-option">
                <input type="checkbox" id="team-submission-checkbox">
                <label for="team-submission-checkbox">Submit for the whole team</label>
            </div>
            <input type="text" id="manual-player-name" placeholder="Manually add other players (comma-separated)">
        </div>
        <input type="hidden" id="player-ids-value" name="player-ids-value">
        <input type="hidden" id="additional-players-value" name="additional-players-value">
        <label id="evidence-label">Evidence:</label>
        <div id="evidence-container"></div>
        <button type="button" id="add-evidence-btn" onclick="addEvidenceInput()">+ Add Evidence Item</button>
        <label for="notes">Notes and Comments:</label>
        <textarea id="notes" rows="3"></textarea>
        <div class="checkbox-container">
            <input type="checkbox" id="mark-as-complete">
            <label for="mark-as-complete">Mark as complete and ready for review</label>
        </div>
        <button type="submit" id="submit-button">Save Progress</button>
      </form>
    </div>
  </div>
  <!-- NEW: Welcome Modal -->
  <div id="welcome-modal">
    <div class="modal-content">
      <h2>Welcome!</h2>
      <p id="welcome-modal-message"></p>
      <form id="welcome-form">
        <label for="welcome-display-name">Your Display Name:</label>
        <input type="text" id="welcome-display-name" required>
        <button type="submit">Save and Continue</button>
      </form>
    </div>
  </div>
  <!-- NEW: Login Modal -->
  <div id="login-modal">
    <div class="modal-content">
      <span class="close-button" onclick="closeLoginModal()">&times;</span>
      <h2>Sign In</h2>
      <p>Choose an option to sign in and participate.</p>
      <div class="login-options">
        <button id="login-google">
          <svg viewBox="0 0 48 48"><path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"></path><path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.42-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"></path><path fill="#FBBC05" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"></path><path fill="#34A853" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"></path><path fill="none" d="M0 0h48v48H0z"></path></svg>
          Sign in with Google
        </button>
        <button id="login-anon">
          <svg viewBox="0 0 24 24"><path fill="currentColor" d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12C20,13.42 19.53,14.74 18.75,15.85L15.85,18.75C14.74,19.53 13.42,20 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4M12,6A6,6 0 0,0 6,12A6,6 0 0,0 12,18A6,6 0 0,0 18,12A6,6 0 0,0 12,6M12,8A4,4 0 0,1 16,12A4,4 0 0,1 12,16A4,4 0 0,1 8,12A4,4 0 0,1 12,8Z"></path></svg>
          Sign in Anonymously
        </button>
      </div>
      <div class="anon-warning">
        <strong>Warning:</strong> Anonymous sign-in has limitations:
        <ul>
          <li>Your progress is tied to <strong>this browser on this device only</strong>. If you log out or clear your cache, you will <strong>not</strong> be able to log back into this anonymous account.</li>
          <li>You cannot be assigned as a team captain, mod, or admin.</li>
        </ul>
      </div>
    </div>
  </div>
  <div id="message-box"></div>
  <!-- NEW: Tooltip element -->
  <div id="tile-tooltip"></div>

  <script type="module">
    import { db, fb } from './firebase-config.js';
    import { initAuth, signInWithGoogle, signInAnonymously, signOut, getAuthState, updateUserDisplayName } from './auth.js';
    import { showMessage, showGlobalLoader, hideGlobalLoader, hexToRgba } from './utils.js';

    let config = {}, allTeams = {}, allStyles = {}, tiles = [], submissions = [], teamData = {}, scoreboard = [], currentTeam = '', authState = {}, allUsers = [];
    let unsubscribeConfig = null, unsubscribeTiles = null, unsubscribeSubmissions = null, unsubscribeStyles = null, unsubscribeUsers = null;

    document.addEventListener('DOMContentLoaded', () => {
        // Initialize data listeners first, then auth. This prevents race conditions.
        initializeApp();
        document.getElementById('change-name-btn').addEventListener('click', () => showWelcomeModal(true));
        document.getElementById('auth-button').addEventListener('click', () => authState.isLoggedIn ? signOut() : openLoginModal());
        document.getElementById('login-google').addEventListener('click', () => { signInWithGoogle(); closeLoginModal(); });
        document.getElementById('login-anon').addEventListener('click', () => { signInAnonymously(); closeLoginModal(); });
        document.getElementById('welcome-form').addEventListener('submit', handleWelcomeFormSubmit);
        initAuth(onAuthStateChanged);
    });

    async function onAuthStateChanged(newAuthState) {
        authState = newAuthState;
        updateNavbar();

        // When auth state changes, team visibility might change (especially for private boards).
        // We need to re-evaluate and re-populate the team selector.
        const loadFirstTeam = config.loadFirstTeamByDefault === true;
        populateTeamSelector(allTeams, loadFirstTeam);
        setupSubmissionsListener(); // Re-setup the submissions listener based on the new auth state.

        // NEW: Welcome modal logic
        // Check if user is logged in, config allows prompting, and user hasn't set their name yet.
        if (authState.isLoggedIn && authState.profile && config.promptForDisplayNameOnLogin === true && authState.profile.hasSetDisplayName !== true) {
            showWelcomeModal();
        }
    }

    function initializeApp() {
        let unsubscribeTeams = null; // New listener for teams

        let initialDataLoaded = { config: false, teams: false, tiles: false, submissions: false, styles: false, users: false };
        const checkAllLoaded = () => {
            if (Object.values(initialDataLoaded).every(Boolean)) {
                hideGlobalLoader();
            }
        };

        showGlobalLoader();

        // Detach old listeners if they exist to prevent memory leaks on hot-reloads
        if (unsubscribeConfig) unsubscribeConfig();
        if (unsubscribeTiles) unsubscribeTiles();
        if (unsubscribeSubmissions) unsubscribeSubmissions();
        if (unsubscribeStyles) unsubscribeStyles();
        if (unsubscribeUsers) unsubscribeUsers();

        // Listener for the main configuration document
        unsubscribeConfig = fb.onSnapshot(fb.doc(db, 'config', 'main'), (doc) => {
            console.log("Config updated in real-time.");
            if (!doc.exists()) {
                document.getElementById('board-container').innerHTML = `<div class="error-message">Board configuration not found. Please contact an admin.</div>`;
                hideGlobalLoader();
                return;
            }
            config = doc.data();

            // After config is loaded, we can set up the other listeners that depend on it.
            setupTilesListener();
            setupSubmissionsListener();
            
            applyGlobalStyles();
            const loadFirstTeam = config.loadFirstTeamByDefault === true;
            populateTeamSelector(allTeams, loadFirstTeam);
            handleTeamChange();

            document.getElementById('overview-nav-link').style.display = config.enableOverviewPage === true ? 'inline-block' : 'none';
            document.getElementById('page-title').textContent = config.pageTitle || 'Bingo';
            renderColorKey();
            renderScoreboard();

            if (!initialDataLoaded.config) { initialDataLoaded.config = true; checkAllLoaded(); }
        }, (error) => { console.error("Error loading config:", error); hideGlobalLoader(); });

        // This function sets up the listener for tiles, respecting censorship rules.
        const setupTilesListener = () => {
            if (unsubscribeTiles) unsubscribeTiles();
            const isCensored = config.censorTilesBeforeEvent === true && !authState.isEventMod;
            const tilesCollectionName = isCensored ? 'public_tiles' : 'tiles';
            console.log(`Board censorship is ${isCensored ? 'ON' : 'OFF'}. Reading from '${tilesCollectionName}'.`);

            unsubscribeTiles = fb.onSnapshot(fb.collection(db, tilesCollectionName), (snapshot) => {
                console.log("Tiles updated in real-time.");
                tiles = snapshot.docs.map(doc => ({ ...doc.data(), docId: doc.id }));
                processAllData();
                renderBoard(); // Render board with new tiles
                if (!initialDataLoaded.tiles) { initialDataLoaded.tiles = true; checkAllLoaded(); }
            }, (error) => { console.error(`Error loading ${tilesCollectionName}:`, error); hideGlobalLoader(); });
        };

        // This function sets up the listener for submissions, respecting privacy rules.
        const setupSubmissionsListener = () => {
            if (unsubscribeSubmissions) unsubscribeSubmissions();
            let submissionsQuery;
            const isPrivateBoard = config.boardVisibility === 'private';
            const isPlayerOnTeam = authState.isLoggedIn && authState.profile?.team;

            if (isPrivateBoard && isPlayerOnTeam && !authState.isEventMod) {
                console.log(`Private board detected. Fetching submissions for team: ${authState.profile.team}`);
                submissionsQuery = fb.query(fb.collection(db, 'submissions'), fb.where('Team', '==', authState.profile.team));
            } else {
                submissionsQuery = fb.collection(db, 'submissions');
            }

            unsubscribeSubmissions = fb.onSnapshot(submissionsQuery, (snapshot) => {
                console.log("Submissions updated in real-time.");
                submissions = snapshot.docs.map(doc => ({ ...doc.data(), docId: doc.id }));
                processAllData();
                renderBoard(); // Re-render board with new submission data
                if (!initialDataLoaded.submissions) { initialDataLoaded.submissions = true; checkAllLoaded(); }
            }, (error) => { console.error("Error loading submissions:", error); hideGlobalLoader(); });
        };

        // Initial setup for listeners that don't depend on config.
        // They will be re-triggered by the config listener once it loads.
        setupTilesListener();
        setupSubmissionsListener();

        // Listener for the new teams collection
        const teamsQuery = fb.query(fb.collection(db, 'teams'), fb.orderBy(fb.documentId()));
        unsubscribeTeams = fb.onSnapshot(teamsQuery, (snapshot) => {
            console.log("Teams updated in real-time.");
            allTeams = {};
            snapshot.docs.forEach(doc => { allTeams[doc.id] = doc.data(); });
            const loadFirstTeam = config.loadFirstTeamByDefault === true;
            const selector = document.getElementById('team-selector');
            const previouslySelected = selector.value; // Keep this to preserve selection on public boards

            populateTeamSelector(allTeams, loadFirstTeam);

            // If the selector is now disabled, its value was set correctly inside populateTeamSelector and we should not touch it.
            // If it's not disabled (public board), try to preserve the previous selection.
            if (!selector.disabled) {
                if (Object.keys(allTeams).includes(previouslySelected)) {
                    selector.value = previouslySelected;
                } else if (loadFirstTeam && Object.keys(allTeams).length > 0) {
                    selector.value = Object.keys(allTeams).sort((a, b) => a.localeCompare(b))[0];
                }
            }
            handleTeamChange(); // Re-render board with new team data
            if (!initialDataLoaded.teams) { initialDataLoaded.teams = true; checkAllLoaded(); }
        }, (error) => { console.error("Error loading teams:", error); hideGlobalLoader(); });

        // Listener for the new styles collection
        unsubscribeStyles = fb.onSnapshot(fb.collection(db, 'styles'), (snapshot) => {
            console.log("Styles updated in real-time.");
            allStyles = {};
            snapshot.docs.forEach(doc => { allStyles[doc.id] = doc.data(); });
            renderColorKey();
            renderBoard(); // Re-render board with new styles
            if (!initialDataLoaded.styles) { initialDataLoaded.styles = true; checkAllLoaded(); }
        }, (error) => { console.error("Error loading styles:", error); });

        // Listener for users collection
        unsubscribeUsers = fb.onSnapshot(fb.collection(db, 'users'), (snapshot) => {
            console.log("Users updated in real-time.");
            allUsers = snapshot.docs.map(doc => ({ ...doc.data(), uid: doc.id }));
            updateNavbar(); // Update navbar in case display name or team changed
            if (!initialDataLoaded.users) { initialDataLoaded.users = true; checkAllLoaded(); }
        }, (error) => { console.error("Error loading users:", error); });
    }

    function updateNavbar() {
        const authButton = document.getElementById('auth-button');
        const userInfo = document.getElementById('user-info');
        const changeNameBtn = document.getElementById('change-name-btn');

        if (authState.isLoggedIn) {
            authButton.textContent = 'Logout';
            const profile = authState.profile || {};
            const roles = [];
            if (profile.isAdmin) { roles.push('Admin'); } else if (profile.isEventMod) { roles.push('Event Mod'); }
            
            const teamName = (profile.team && allTeams) ? (allTeams[profile.team]?.name || profile.team) : '';
            const roleString = roles.length > 0 ? `(${roles.join(', ')})` : '';
            const teamInfo = teamName ? ` | Team: ${teamName}` : '';
            userInfo.textContent = `${profile.displayName || 'User'} ${roleString} ${teamInfo}`;

            // NEW: Show change name button if user is not anonymous and name is not locked
            const canChangeName = !profile.isNameLocked;
            changeNameBtn.style.display = canChangeName ? 'inline-block' : 'none';
        } else {
            authButton.textContent = 'Login';
            changeNameBtn.style.display = 'none';
            userInfo.textContent = '';
        }

        document.getElementById('admin-nav-link').style.display = authState.isEventMod ? 'inline-block' : 'none'; // isEventMod now includes Admin
        document.getElementById('setup-nav-link').style.display = authState.isAdmin ? 'inline-block' : 'none';
    }

    function processAllData() {
        teamData = {};
        const newScoreboard = [];
        const teamIds = allTeams ? Object.keys(allTeams) : [];

        teamIds.forEach(teamId => {
            const teamSubmissions = submissions.filter(s => s.Team === teamId && !s.IsArchived);
            const tileStates = {};

            teamSubmissions.forEach(sub => { // sub.id is the user-facing tile ID
                const tileId = sub.id;
                if (!tileStates[tileId]) {
                    tileStates[tileId] = { hasSubmission: false, complete: false, verified: false, requiresAction: false };
                }
                tileStates[tileId].hasSubmission = true;
                if (sub.IsComplete) tileStates[tileId].complete = true;
                if (sub.AdminVerified) tileStates[tileId].verified = true;
                if (sub.RequiresAction) tileStates[tileId].requiresAction = true;
            });
            teamData[teamId] = { tileStates };
        });

        // Calculate scoreboard
        teamIds.forEach(teamId => {
            let score = 0;
            let completedTiles = 0;
            tiles.forEach(tile => {
                const status = getTileStatus(tile, teamId);
                const scoreOnVerified = config.scoreOnVerifiedOnly === true;
                const isScored = scoreOnVerified ? status === 'Verified' : (status === 'Verified' || status === 'Submitted');

                if (isScored) {
                    score += parseInt(tile.Points) || 0;
                    completedTiles++;
                }
            });
            newScoreboard.push({ teamId: teamId, score, completedTiles });
        });

        scoreboard = newScoreboard.sort((a, b) => b.score - a.score);
    }
    
    function applyGlobalStyles() {
        if (!config) return;
        const elements = document.querySelectorAll('.navbar, .controls, #board-container, .info-container');

        let configValue = config.maxPageWidth;
        let maxWidth;

        if (configValue && configValue.trim() !== '') {
            // If a value is provided, process it.
            // Check if it's a plain number string (e.g., "500").
            if (/^\d+$/.test(configValue.trim())) {
                // If so, append 'px' to make it a valid CSS value.
                maxWidth = `${configValue.trim()}px`;
            } else {
                // Otherwise, use the value as is (e.g., "500px", "90%", "none").
                maxWidth = configValue;
            }
        } else {
            // If the config value is missing, null, or an empty string, use the default.
            maxWidth = '1400px';
        }
        elements.forEach(el => el.style.maxWidth = maxWidth);
    }

    function populateTeamSelector(teams = {}, loadFirstTeam = false) {
        const selector = document.getElementById('team-selector');
        selector.innerHTML = '';
        selector.disabled = false; // Enable by default

        const isPrivate = config.boardVisibility === 'private';

        if (isPrivate) {
            if (authState.isLoggedIn && authState.profile?.team) {
                // Private board, user is on a team: Lock to their team.
                const teamId = authState.profile.team;
                const teamData = teams[teamId];
                if (teamData) {
                    const option = document.createElement('option');
                    option.value = teamId;
                    option.textContent = teamData.name;
                    selector.appendChild(option);
                    selector.value = teamId;
                    selector.disabled = true;
                } else {
                    // Edge case: user's team doesn't exist in allTeams. Treat as no team.
                    selector.innerHTML = '<option value="" selected disabled>Select a Team...</option>';
                    selector.disabled = true;
                }
            } else {
                // Private board, user not logged in or not on a team: Show disabled placeholder.
                selector.innerHTML = '<option value="" selected disabled>Select a Team...</option>';
                selector.disabled = true;
            }
        } else {
            // Public board: Original behavior
            if (!loadFirstTeam) {
                const placeholder = document.createElement('option');
                placeholder.value = "";
                placeholder.textContent = "Select a Team...";
                placeholder.disabled = true;
                placeholder.selected = true;
                selector.appendChild(placeholder);
            }
            Object.entries(teams).sort((a, b) => a[0].localeCompare(b[0])).forEach(([id, teamData]) => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = teamData.name;
                selector.appendChild(option);
            });
        }
    }

    function isGenericView() {
        // Scenario 1: Board is private, and the user is either not logged in or not on a team.
        if (config.boardVisibility === 'private' && (!authState.isLoggedIn || !authState.profile?.team)) return true;
        // Scenario 2: Board is public, but no team is selected and the config doesn't load one by default.
        if (config.boardVisibility !== 'private' && !currentTeam && config.loadFirstTeamByDefault !== true) return true;
        return false;
    }

    function handleTeamChange() {
      const selector = document.getElementById('team-selector');
      currentTeam = selector.value;
      renderBoard();
    }

    function getTileStatus(tile, teamName) {
        if (isGenericView()) return 'Unlocked';

        const isPublic = config.boardVisibility !== 'private';
        // The teamName parameter is now a teamId
        if (!isPublic && teamName && teamName !== authState.profile?.team) {
            // On a private board, if you're viewing a team that isn't yours, tiles are hidden.
            // This is a safeguard; the UI should prevent selecting other teams anyway.
            return 'Hidden';
        }

        if (!teamName || !teamData[teamName]) return 'Locked'; // teamName is teamId
        const teamTileStates = teamData[teamName].tileStates;
        const state = teamTileStates[tile.id] || {}; // tile.id is the user-facing ID
        if (state.verified) return 'Verified';
        if (state.requiresAction) return 'Requires Action';
        if (state.complete) return 'Submitted';
        if (state.hasSubmission) return 'Partially Complete';

        const unlockOnVerifiedOnly = config.unlockOnVerifiedOnly === true;
        // The server's getBoardData() may split the 'Prerequisites' column by comma.
        // We rejoin it here to reconstruct the original string, which could be a simple list or a JSON array string.
        const prereqString = tile.Prerequisites || '';

        if (!prereqString || !prereqString.trim()) {
            return 'Unlocked'; // No prerequisites.
        }

        let orGroups = [];
        let isNewFormat = false;

        // Try to parse as JSON for the new AND/OR logic: e.g., [["A1","A2"],["B1"]]
        if (prereqString.trim().startsWith('[')) {
            try {
                const parsed = JSON.parse(prereqString);
                // Check if it's an array of arrays (or an empty array for an unlocked tile)
                if (Array.isArray(parsed) && (parsed.length === 0 || Array.isArray(parsed[0]))) {
                    orGroups = parsed;
                    isNewFormat = true;
                }
            } catch (e) {
                // Not valid JSON, will fall through to old format handling.
            }
        }

        if (!isNewFormat) {
            // Fallback to old format: a single AND group from a comma-separated list.
            const andGroup = prereqString.split(',').map(s => s.trim()).filter(Boolean);
            orGroups = andGroup.length > 0 ? [andGroup] : [];
        }

        if (orGroups.length === 0) {
            return 'Unlocked'; // No prerequisites after parsing.
        }

        // Check if any 'OR' group is satisfied.
        const prereqsMet = orGroups.some(andGroup => {
            // An empty AND group `[]` is vacuously true because `[].every()` returns true.
            return andGroup.every(prereqId => {
                const prereqState = teamTileStates[prereqId] || {};
                return unlockOnVerifiedOnly ? prereqState.verified : (prereqState.verified || prereqState.complete);
            });
        });
        return prereqsMet ? 'Unlocked' : 'Locked';
    }

    function renderBoard() {
      const shouldShowGeneric = isGenericView();
      // Clear the board if there are no tiles, OR if no team is selected AND we are not in a generic view.
      if (!tiles || tiles.length === 0 || (!currentTeam && !shouldShowGeneric)) {
        document.getElementById('board-container').innerHTML = '';
        document.getElementById('page-title').textContent = config.pageTitle || 'Bingo'; // Set title when board is cleared
        return;
      }

      const container = document.getElementById('board-container');
      container.innerHTML = '';
      const displayTeam = currentTeam;
      const displayTeamName = (displayTeam && allTeams) ? (allTeams[displayTeam]?.name || displayTeam) : '';
      
      if (displayTeam) {
        document.title = `${config.pageTitle || 'Bingo'} : ${displayTeamName}`;
      } else {
        document.title = config.pageTitle || 'Bingo';
      }
      document.getElementById('page-title').textContent = displayTeam ? displayTeamName : (config.pageTitle || 'Bingo');
      const tooltip = document.getElementById('tile-tooltip');

      const renderTiles = () => {
        tiles.forEach(tile => {
          if (getTileStatus(tile, displayTeam) === 'Hidden') return;
          const tileDiv = document.createElement('div');
          const status = getTileStatus(tile, displayTeam);
          tileDiv.className = `tile-overlay ${status.replace(/\s+/g, '-').toLowerCase()}`;

          // --- NEW: Handle censored data ---
          const tileName = tile.Name || 'Censored';
          const tileDesc = tile.Description || 'This tile is hidden until the event begins.';

          const getProp = (propName, status) => {
              // 1. Check tile-specific overrides for the given status
              if (tile['Overrides (JSON)']) {
                  try {
                      const overrides = JSON.parse(tile['Overrides (JSON)']);
                      if (overrides[status] && overrides[status][propName] !== undefined) {
                          return overrides[status][propName];
                      }
                  } catch (e) {}
              }
              // 2. Check status-specific styles
              const statusStyle = allStyles[status];
              if (statusStyle && statusStyle[propName] !== undefined) {
                  return statusStyle[propName];
              }
              // 3. Fallback to global config defaults
              return config[propName];
          };

          tileDiv.style.top = `${tile['Top (%)']}%`; tileDiv.style.left = `${tile['Left (%)']}%`;
          tileDiv.style.width = `${tile['Width (%)']}%`; tileDiv.style.height = `${tile['Height (%)']}%`;
          tileDiv.style.transform = `rotate(${tile.Rotation || '0deg'})`;
          
          const color = getProp('color', status) || '#FFFFFF';
          const opacity = getProp('opacity', status) || 0.7;
          tileDiv.style.backgroundColor = hexToRgba(color, opacity);
          const shape = (getProp('shape', status) || 'Square').toLowerCase();
          const clipPaths = { 'ellipse': 'ellipse(50% 50% at 50% 50%)', 'circle': 'ellipse(50% 50% at 50% 50%)', 'diamond': 'polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)', 'triangle': 'polygon(50% 0%, 0% 100%, 100% 100%)', 'hexagon': 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)' };
          if (clipPaths[shape]) tileDiv.style.clipPath = clipPaths[shape];
          const borderWidth = getProp('borderWidth', status) || '2px';
          const borderColor = getProp('borderColor', status) || 'transparent';
          tileDiv.style.border = `${borderWidth} solid ${borderColor}`;
          
          // --- UPDATED: Tooltip logic ---
          tileDiv.addEventListener('mousemove', (e) => {
              tooltip.innerHTML = `<h4>${tile.id}: ${tileName}</h4><p>${tileDesc}</p>`;
              tooltip.style.display = 'block';
              // Position tooltip relative to cursor
              tooltip.style.left = `${e.clientX + 15}px`;
              tooltip.style.top = `${e.clientY + 15}px`;
          });
          tileDiv.addEventListener('mouseout', () => {
              tooltip.style.display = 'none';
              tileDiv.style.border = `${borderWidth} solid ${borderColor}`;
          });
          tileDiv.addEventListener('mouseover', () => {
              const hoverWidth = getProp('hoverBorderWidth', status) || '3px';
              const hoverColor = getProp('hoverBorderColor', status) || 'var(--accent-color)';
              tileDiv.style.border = `${hoverWidth} solid ${hoverColor}`;
          });

          if(config.showTileNames === true || !config.boardImageUrl) {
            const tileNameSpan = document.createElement('span');
            tileNameSpan.textContent = tileName;
            tileDiv.appendChild(tileNameSpan);
          }
          const useStamp = getProp('useStampByDefault', status) === true;
          const stampImg = getProp('stampImageUrl', status);
          if (useStamp && stampImg) {
              const stampScale = getProp('stampScale', status) || 1;
              const stampRotation = getProp('stampRotation', status) || '0deg';
              const stampPosition = getProp('stampPosition', status) || 'center';
              const stampDiv = document.createElement('div');
              stampDiv.className = 'stamp-image';
              stampDiv.style.backgroundImage = `url('${stampImg}')`;
              stampDiv.style.backgroundPosition = stampPosition;
              stampDiv.style.transformOrigin = stampPosition;
              stampDiv.style.transform = `scale(${stampScale}) rotate(${stampRotation})`;
              tileDiv.appendChild(stampDiv);
          }

          // In generic view, modals cannot be opened.
          const genericView = isGenericView();
          const canOpenModal = !genericView && displayTeam && status !== 'Locked' && authState.isLoggedIn && authState.profile?.team === displayTeam;


            if (canOpenModal) {
                tileDiv.onclick = () => openModal(tile, status);
            } else if (!displayTeam) {
                tileDiv.onclick = () => showMessage('Please select a team to interact with a tile.', true);
            } else if (displayTeam && status !== 'Locked') {
                // Tile is visible but not interactive for this user (e.g., public board, wrong team)
                tileDiv.style.cursor = 'not-allowed';
            }

          container.appendChild(tileDiv);
        });
      };

      // Helper function to apply the default placeholder background styles
      const setPlaceholderBackground = () => {
          container.style.backgroundImage = 'linear-gradient(45deg, #2a2a2a 25%, transparent 25%), linear-gradient(-45deg, #2a2a2a 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #2a2a2a 75%), linear-gradient(-45deg, transparent 75%, #2a2a2a 75%)';
          container.style.backgroundSize = '20px 20px';
          container.style.backgroundRepeat = 'repeat';
          container.style.aspectRatio = '1 / 1';
      };

      const imageUrl = config.boardImageUrl;
      if (!imageUrl) {
        setPlaceholderBackground();
        renderTiles(); return;
      }
      const img = new Image();
      img.onload = () => {
        container.style.aspectRatio = `${img.naturalWidth} / ${img.naturalHeight}`;
        container.style.backgroundImage = `url('${imageUrl}')`;
        // FIX: Explicitly set the background size and repeat properties for the real image
        container.style.backgroundSize = 'cover';
        container.style.backgroundRepeat = 'no-repeat';
        renderTiles();
      };
      img.onerror = () => {
        // On error, revert to the placeholder background
        setPlaceholderBackground();
        const errorDiv = document.createElement('div'); errorDiv.className = 'error-message';
        errorDiv.innerHTML = `<strong>Image Failed to Load</strong>`;
        container.appendChild(errorDiv); renderTiles();
      };
      img.src = imageUrl;
    }
    
    function renderColorKey() {
        if (!config || !allStyles) return;
        const keyContainer = document.getElementById('color-key-container');
        keyContainer.innerHTML = '';
        const keyOrder = ['Locked', 'Unlocked', 'Partially Complete', 'Submitted', 'Verified', 'Requires Action'];

        keyOrder.forEach(status => {
            const style = allStyles[status] || {}; // Default to empty object if style is not defined

            // Provide defaults for color and opacity if not defined in the style object
            const color = style.color || '#888888'; // Default to a neutral grey
            const opacity = style.opacity ?? 0.7; // Use nullish coalescing to correctly handle opacity: 0

            const keyItem = document.createElement('div');
            keyItem.className = 'key-item';
            const colorBox = document.createElement('div');
            colorBox.className = 'key-color-box';
            colorBox.style.backgroundColor = hexToRgba(color, opacity);

            const useStamp = style.useStampByDefault === true;
            const stampImg = style.stampImageUrl;
            if (useStamp && stampImg) {
                colorBox.style.backgroundImage = `url('${stampImg}')`;
            }

            const keyLabel = document.createElement('span');
            keyLabel.textContent = status;
            keyItem.appendChild(colorBox);
            keyItem.appendChild(keyLabel);
            keyContainer.appendChild(keyItem);
        });
    }

    function renderScoreboard() {
        const container = document.getElementById('scoreboard-container');
        if (!config || config.showScoreboard !== true) {
            container.style.display = 'none'; return;
        }
        container.style.display = 'flex';
        container.innerHTML = '<h2>Scoreboard</h2>';

        let dataToRender = scoreboard;
        const isPrivate = config.boardVisibility === 'private';

        // Filter scoreboard data for private boards
        if (isPrivate) {
            if (authState.isLoggedIn && authState.profile?.team) {
                // User is on a team, show only their team
                dataToRender = scoreboard.filter(item => item.teamId === authState.profile.team);
            } else {
                // User not on a team, show no scores
                dataToRender = [];
            }
        }

        if (dataToRender.length === 0) {
            const noScoreItem = document.createElement('div');
            noScoreItem.textContent = 'No scores to display.';
            noScoreItem.style.textAlign = 'center';
            noScoreItem.style.color = '#888';
            container.appendChild(noScoreItem);
        } else {
            dataToRender.forEach((team) => {
                const item = document.createElement('div');
                item.className = 'scoreboard-item';
                const teamName = (allTeams && allTeams[team.teamId]) ? allTeams[team.teamId].name : team.teamId;
                if (isPrivate) {
                    // For private boards, hide rank and adjust grid
                    item.style.gridTemplateColumns = '1fr 60px';
                    item.innerHTML = `<div class="scoreboard-team">${teamName}</div><div class="scoreboard-score">${team.score}</div>`;
                } else {
                    // For public boards, show rank as normal
                    const originalIndex = scoreboard.findIndex(item => item.teamId === team.teamId);
                    const rank = originalIndex !== -1 ? originalIndex + 1 : '-';
                    item.innerHTML = `<div class="scoreboard-rank">${rank}.</div><div class="scoreboard-team">${teamName}</div><div class="scoreboard-score">${team.score}</div>`;
                }
                container.appendChild(item);
            });
        }
    }

    // --- NEW: Dynamic Evidence Field Functions ---
    function addEvidenceInput(link = '', name = '') {
        const container = document.getElementById('evidence-container');
        const itemCount = container.children.length;

        const evidenceItemDiv = document.createElement('div');
        evidenceItemDiv.className = 'evidence-item';

        // Swapped link and name inputs, and updated placeholder text for clarity.
        evidenceItemDiv.innerHTML = `
            <div class="evidence-item-header">
                <label>Evidence #${itemCount + 1}</label>
                <button type="button" class="remove-evidence-btn" onclick="this.parentElement.parentElement.remove(); renumberEvidenceItems();">&times;</button>
            </div>
            <input type="text" class="evidence-name" placeholder="Optional: name or short description" value="${name}">
            <input type="text" class="evidence-link" placeholder="Link (e.g., https://discord...)" value="${link}">
        `;
        container.appendChild(evidenceItemDiv);
    }

    window.renumberEvidenceItems = function renumberEvidenceItems() {
        const container = document.getElementById('evidence-container');
        const items = container.querySelectorAll('.evidence-item');
        items.forEach((item, index) => {
            const label = item.querySelector('label');
            if (label) {
                label.textContent = `Evidence #${index + 1}`;
            }
        });
    }

    function clearEvidenceInputs() {
        const container = document.getElementById('evidence-container');
        container.innerHTML = '';
    }

    function populatePlayerNameSelector(savedPlayerIDs = [], savedAdditionalNames = '') {
        const membersContainer = document.getElementById('team-members-checkboxes');
        const teamCheckbox = document.getElementById('team-submission-checkbox');
        const manualInput = document.getElementById('manual-player-name');

        membersContainer.innerHTML = '';
        // Reset listeners and values
        teamCheckbox.checked = false;
        manualInput.value = '';

        // 1. Get team members and populate checkboxes
        const teamMembers = allUsers.filter(u => u.team === currentTeam);
        teamMembers.forEach(member => {
            const id = `player-check-${member.uid}`;
            const item = document.createElement('div');
            item.className = 'player-checkbox-item';
            // Use data-uid to store the user's ID
            item.innerHTML = `
                <input type="checkbox" id="${id}" data-uid="${member.uid}">
                <label for="${id}">${member.displayName}</label>
            `;
            membersContainer.appendChild(item);
        });

        // 2. Pre-fill the form based on saved data
        const teamName = allTeams[currentTeam]?.name || currentTeam;
        // Check if the submission was for the whole team
        if (savedAdditionalNames === teamName && savedPlayerIDs.length === 0) {
            teamCheckbox.checked = true;
        } else {
            // Check the boxes for saved player UIDs
            savedPlayerIDs.forEach(uid => {
                const memberCheckbox = membersContainer.querySelector(`[data-uid="${uid}"]`);
                if (memberCheckbox) memberCheckbox.checked = true;
            });
            // Populate the manual input with any additional names
            manualInput.value = savedAdditionalNames;
        }

        // 3. Add a single event listener to the container
        const container = document.getElementById('player-name-container');
        container.removeEventListener('input', updatePlayerNameField); // Clear old listener to prevent duplicates
        container.addEventListener('input', updatePlayerNameField);

        // 4. Initial update to set the hidden field values
        updatePlayerNameField();
    }

    function updatePlayerNameField() {
        const membersContainer = document.getElementById('team-members-checkboxes');
        const teamCheckbox = document.getElementById('team-submission-checkbox');
        const manualInput = document.getElementById('manual-player-name');
        const playerIdsInput = document.getElementById('player-ids-value');
        const additionalNamesInput = document.getElementById('additional-players-value');

        const teamName = allTeams[currentTeam]?.name || currentTeam;

        // If "Submit for whole team" is checked, it overrides everything else.
        if (teamCheckbox.checked) {
            playerIdsInput.value = JSON.stringify([]);
            additionalNamesInput.value = teamName;
            membersContainer.querySelectorAll('input').forEach(i => { i.checked = false; i.disabled = true; });
            manualInput.value = ''; manualInput.disabled = true; return;
        }

        // Otherwise, enable other inputs and collect their values.
        membersContainer.querySelectorAll('input').forEach(i => i.disabled = false);
        manualInput.disabled = false;
        const selectedUIDs = Array.from(membersContainer.querySelectorAll('input:checked')).map(cb => cb.dataset.uid);
        playerIdsInput.value = JSON.stringify(selectedUIDs);
        additionalNamesInput.value = manualInput.value.trim();
    }

    function openModal(tile, status) {
      const modal = document.getElementById('submission-modal');
      const form = document.getElementById('submission-form');
      form.reset();
      document.getElementById('admin-feedback-display').style.display = 'none'; // Hide feedback by default

      document.getElementById('modal-tile-id').value = tile.id; // The user-facing ID
      document.getElementById('modal-tile-name').textContent = `${tile.id}: ${tile.Name || 'Censored'}`; // Handle censored name
      const teamName = (allTeams && allTeams[currentTeam]) ? allTeams[currentTeam].name : currentTeam;
      document.getElementById('modal-team-name').textContent = `Team: ${teamName}`;
      document.getElementById('modal-tile-desc').textContent = tile.Description || 'This tile is hidden until the event begins.'; // Handle censored desc
      document.getElementById('evidence-label').textContent = config.evidenceFieldLabel || 'Evidence:';

      modal.style.display = 'flex';
      const isEditable = status !== 'Verified';

      const existingSubmission = submissions.find(s => s.Team === currentTeam && s.id === tile.id && !s.IsArchived);

      populatePlayerNameSelector(existingSubmission?.PlayerIDs || [], existingSubmission?.AdditionalPlayerNames || '');
      document.getElementById('notes').value = existingSubmission?.Notes || '';
      document.getElementById('mark-as-complete').checked = existingSubmission?.IsComplete || false;

      let evidenceData = [];
      if (existingSubmission?.Evidence) {
          try {
              evidenceData = JSON.parse(existingSubmission.Evidence);
              if (!Array.isArray(evidenceData)) throw new Error("Not an array");
          } catch (e) {
              if (existingSubmission.Evidence) evidenceData = [{ link: existingSubmission.Evidence, name: '' }];
          }
      }
      
      clearEvidenceInputs();
      if (evidenceData.length > 0) {
          evidenceData.forEach(item => addEvidenceInput(item.link, item.name));
      } else if (isEditable) {
          addEvidenceInput();
      }

      const formElements = document.querySelectorAll('#submission-form input, #submission-form textarea, #submission-form button');
      const submitButton = document.getElementById('submit-button');
      submitButton.className = ''; // Reset button style

      if (isEditable) {
          formElements.forEach(el => el.disabled = false);
          // NEW: Check for admin feedback to change button text/style
          if (existingSubmission?.AdminFeedback) {
              document.getElementById('admin-feedback-display').style.display = 'block';
              document.getElementById('admin-feedback-text').textContent = existingSubmission.AdminFeedback;
              submitButton.textContent = 'Resubmit for Review';
              submitButton.classList.add('resubmit-btn');
          } else {
              submitButton.textContent = 'Save Progress';
          }
      } else {
          formElements.forEach(el => el.disabled = true);
          submitButton.textContent = 'Verified (Locked)';
      }
    }

    function closeModal() {
      document.getElementById('submission-modal').style.display = 'none';
    }

    async function handleFormSubmit(event) {
      event.preventDefault();
      const submitButton = document.getElementById('submit-button');
      submitButton.disabled = true;
      showGlobalLoader();

      // --- NEW: Collect evidence data ---
      const evidenceItems = [];
      document.querySelectorAll('#evidence-container .evidence-item').forEach(item => {
          const link = item.querySelector('.evidence-link').value.trim();
          const name = item.querySelector('.evidence-name').value.trim();
          if (link || name) { // Only add if at least one field is filled
              evidenceItems.push({ link, name });
          }
      });

      const canSubmit = authState.isLoggedIn && authState.profile?.team === currentTeam;
      if (!canSubmit) {
          showMessage('You do not have permission to submit for this team.', true);
          submitButton.disabled = false;
          hideGlobalLoader();
          return;
      }
      
      const tileId = document.getElementById('modal-tile-id').value;
      const existingSubmission = submissions.find(s => s.Team === currentTeam && s.id === tileId && !s.IsArchived);

      const dataToSave = {
        PlayerIDs: JSON.parse(document.getElementById('player-ids-value').value || '[]'),
        AdditionalPlayerNames: document.getElementById('additional-players-value').value,
        Evidence: JSON.stringify(evidenceItems),
        Notes: document.getElementById('notes').value,
        Team: currentTeam,
        id: tileId, // Save the user-facing tile ID
        IsComplete: document.getElementById('mark-as-complete').checked,
      };
      
      // FIX: Define historyEntry before using it.
      const historyEntry = {
          timestamp: new Date(),
          user: { uid: authState.user.uid, name: authState.profile.displayName },
          changes: []
      };

      // If this is a resubmission, clear the feedback and "Requires Action" flag
      if (existingSubmission?.AdminFeedback) {
          historyEntry.action = 'Player Resubmission';
          historyEntry.changes.push({ field: 'AdminFeedback', from: `"${existingSubmission.AdminFeedback}"`, to: 'Acknowledged & Cleared' });
          dataToSave.RequiresAction = false; // Player has addressed the issue
          dataToSave.AdminFeedback = ''; // Clear the feedback message
      } else {
          historyEntry.action = 'Player Update';
      }

      try {
          if (existingSubmission) {
              // Use the correct document ID to get the reference for updating.
              const subRef = fb.doc(db, 'submissions', existingSubmission.docId);
              // Log specific changes by comparing against original values
              if (dataToSave.IsComplete !== !!existingSubmission.IsComplete) historyEntry.changes.push({ field: 'IsComplete', from: !!existingSubmission.IsComplete, to: dataToSave.IsComplete });
              if (JSON.stringify(dataToSave.PlayerIDs) !== JSON.stringify(existingSubmission.PlayerIDs || [])) historyEntry.changes.push({ field: 'PlayerIDs', from: 'Previous players', to: 'New players' });
              if (dataToSave.AdditionalPlayerNames !== (existingSubmission.AdditionalPlayerNames || '')) historyEntry.changes.push({ field: 'AdditionalPlayerNames', from: existingSubmission.AdditionalPlayerNames || '', to: dataToSave.AdditionalPlayerNames });
              if (dataToSave.Notes !== (existingSubmission.Notes || '')) historyEntry.changes.push({ field: 'Notes', from: existingSubmission.Notes || '', to: dataToSave.Notes });
              const oldEvidence = existingSubmission.Evidence || '[]';
              if (dataToSave.Evidence !== oldEvidence) historyEntry.changes.push({ field: 'Evidence', from: 'Previous evidence', to: 'New evidence' }); // Keep it simple for evidence

              // Only add history if there were actual changes
              if (historyEntry.changes.length > 0) {
                  dataToSave.history = fb.arrayUnion(historyEntry);
              }

              if (dataToSave.IsComplete && !existingSubmission.IsComplete) {
                  dataToSave.CompletionTimestamp = fb.serverTimestamp();
              }
              await fb.updateDoc(subRef, dataToSave);
          } else {
              dataToSave.Timestamp = fb.serverTimestamp(); // This call is correct
              if (dataToSave.IsComplete) {
                  dataToSave.CompletionTimestamp = fb.serverTimestamp();
              }
              historyEntry.action = 'Player Create';
              dataToSave.history = [historyEntry];
              await fb.addDoc(fb.collection(db, 'submissions'), dataToSave);
          }
          showMessage('Submission saved!', false);
          closeModal();
      } catch (error) {
          showMessage('Submission failed: ' + error.message, true);
          console.error("Submission error:", error);
      } finally {
          submitButton.disabled = false;
          hideGlobalLoader();
      }
    }

    // --- NEW: Welcome Modal Functions ---
    function showWelcomeModal(isUpdate = false) {
        const modal = document.getElementById('welcome-modal');
        const messageEl = document.getElementById('welcome-modal-message');
        const nameInput = document.getElementById('welcome-display-name');
        const titleEl = modal.querySelector('h2');

        const defaultMessage = 'Please set your display name for the event. This will be shown on leaderboards and submissions.';

        if (isUpdate) {
            titleEl.textContent = 'Update Display Name';
        } else {
            titleEl.textContent = 'Welcome!';
        }
        messageEl.textContent = (config.welcomeMessage || defaultMessage).replace('{displayName}', authState.profile.displayName || 'User');
        nameInput.value = authState.profile.displayName || '';
        modal.style.display = 'flex';
    }

    async function handleWelcomeFormSubmit(event) {
        event.preventDefault();
        const submitBtn = event.target.querySelector('button[type="submit"]');
        submitBtn.disabled = true;
        const newName = document.getElementById('welcome-display-name').value.trim();
        if (!newName || !authState.isLoggedIn) return;

        try {
            await updateUserDisplayName(newName);
            document.getElementById('welcome-modal').style.display = 'none';
            showMessage('Display name updated!', false);
        } catch (error) {
            showMessage('Failed to update display name: ' + error.message, true);
            console.error('Display name update error:', error);
        } finally {
            submitBtn.disabled = false;
        }
    }

    // --- NEW: Login Modal Functions ---
    function openLoginModal() {
        document.getElementById('login-modal').style.display = 'flex';
    }
    function closeLoginModal() {
        document.getElementById('login-modal').style.display = 'none';
    }

    // Expose functions to global scope for onclick handlers
    window.handleTeamChange = handleTeamChange;
    window.closeModal = closeModal;
    window.handleFormSubmit = handleFormSubmit;
    window.addEvidenceInput = addEvidenceInput;
    window.closeLoginModal = closeLoginModal;

  </script>
</body>
</html>